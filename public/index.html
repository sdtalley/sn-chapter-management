<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SN Chapter Management</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- UNAUTHORIZED ACCESS MESSAGE -->
        <div id="unauthorized" class="unauthorized" style="display: none;">
            <h2>Unauthorized Access</h2>
            <p>You do not have permission to access this application.</p>
            <p>Please contact your administrator for access.</p>
        </div>

        <!-- MAIN MENU (Visible by default) -->
        <div id="main-menu" class="main-menu">
            <h2>Chapter Management</h2>
            <div class="nav-buttons">
                <button class="nav-btn" id="btn-verify-candidates" onclick="showPage('verify-candidates')">Verify Candidates</button>
                <button class="nav-btn" id="btn-verify-initiates" onclick="showPage('verify-initiates')">Verify Initiates</button>
                <button class="nav-btn" id="btn-roster-info" onclick="showPage('roster-info')">Roster Information</button>
                <button class="nav-btn" id="btn-officer-info" onclick="showPage('officer-info')">Officer Information</button>
                <button class="nav-btn" id="btn-contact-info" onclick="showPage('contact-info')">Chapter Contact Information</button>
                <button class="nav-btn" id="btn-fee-status" onclick="showPage('fee-status')">Fee Status</button>
                <button class="nav-btn" id="btn-admin" onclick="showPage('admin')">Admin</button>
            </div>
        </div>

        <!-- VERIFY CANDIDATES PAGE -->
        <div id="verify-candidates" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Verify Candidates</h2>
            
            <div class="loading-message" id="candidates-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading prospective candidates...</p>
            </div>
            
            <div id="candidates-content" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="candidates-chapter">-</span></p>
                    <p><strong>Total Prospective Candidates:</strong> <span id="candidates-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="candidates-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Approve</th>
                                <th>Candidate Ceremony Date</th>
                            </tr>
                        </thead>
                        <tbody id="candidates-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="reviewCandidateChanges()">Review Changes</button>
                </div>
            </div>
            
            <!-- CANDIDATES REVIEW SECTION -->
            <div id="candidates-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="candidates-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="candidates-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="candidates-review-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Approval Status</th>
                                <th>Candidate Ceremony Date</th>
                            </tr>
                        </thead>
                        <tbody id="candidates-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToCandidates()">Back</button>
                    <button class="btn" onclick="submitCandidateVerifications()">Submit</button>
                </div>
            </div>
            
            <div id="candidates-error" class="error-message" style="display: none;">
                <p>Error loading candidates. Please try again or check your authentication.</p>
                <button class="btn" onclick="loadCandidates()">Retry</button>
            </div>
            
            <!-- CANDIDATES REVIEW SECTION -->
            <div id="candidates-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="candidates-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="candidates-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="candidates-review-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Approval Status</th>
                                <th>Candidate Ceremony Date</th>
                            </tr>
                        </thead>
                        <tbody id="candidates-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToCandidates()">Back</button>
                    <button class="btn" onclick="submitCandidateVerifications()">Submit</button>
                </div>
            </div>
        </div>

        <!-- VERIFY INITIATES PAGE -->
        <div id="verify-initiates" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Verify Initiates</h2>
            
            <div class="loading-message" id="initiates-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading candidates...</p>
            </div>
            
            <div id="initiates-content" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="initiates-chapter">-</span></p>
                    <p><strong>Total Candidates:</strong> <span id="initiates-count">0</span></p>
                    <p id="last-badge-info" style="display: none;"><strong>The last badge assigned is <span id="last-badge-number">-</span>.</strong></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="initiates-table">
                        <thead>
                            <tr>
                                <th>Initiated</th>
                                <th>Name</th>
                                <th>Candidate Ceremony Date</th>
                                <th>Initiate Ceremony Date</th>
                                <th>Badge Number</th>
                            </tr>
                        </thead>
                        <tbody id="initiates-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="reviewInitiateChanges()">Review Changes</button>
                </div>
            </div>
            
            <!-- INITIATES REVIEW SECTION -->
            <div id="initiates-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="initiates-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="initiates-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="initiates-review-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Initiate Ceremony Date</th>
                                <th>Badge Number</th>
                            </tr>
                        </thead>
                        <tbody id="initiates-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToInitiates()">Back</button>
                    <button class="btn" onclick="submitInitiateVerifications()">Submit</button>
                </div>
            </div>
            
            <div id="initiates-error" class="error-message" style="display: none;">
                <p>Error loading initiates. Please try again or check your authentication.</p>
                <button class="btn" onclick="loadInitiates()">Retry</button>
            </div>
            
            <!-- INITIATES REVIEW SECTION -->
            <div id="initiates-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="initiates-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="initiates-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="initiates-review-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Initiate Ceremony Date</th>
                                <th>Badge Number</th>
                            </tr>
                        </thead>
                        <tbody id="initiates-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToInitiates()">Back</button>
                    <button class="btn" onclick="submitInitiateVerifications()">Submit</button>
                </div>
            </div>
        </div>

        <!-- ROSTER INFORMATION PAGE -->
        <div id="roster-info" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Roster Information</h2>
            
            <div class="loading-message" id="roster-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading roster information...</p>
            </div>
            
            <div id="roster-content" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="roster-chapter">-</span></p>
                    <p><strong>Total Candidates:</strong> <span id="roster-candidates-count">0</span></p>
                    <p><strong>Total Initiates:</strong> <span id="roster-initiates-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="roster-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Current</th>
                                <th>From Date</th>
                                <th>Status</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="roster-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="reviewRosterChanges()">Review Changes</button>
                </div>
            </div>
            
            <!-- ROSTER REVIEW SECTION -->
            <div id="roster-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="roster-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="roster-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="roster-review-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Current Status</th>
                                <th>New Status</th>
                                <th>Effective Date</th>
                            </tr>
                        </thead>
                        <tbody id="roster-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToRoster()">Back</button>
                    <button class="btn" onclick="submitRosterChanges()">Submit</button>
                </div>
            </div>
            
            <div id="roster-error" class="error-message" style="display: none;">
                <p>Error loading roster. Please try again or check your authentication.</p>
                <button class="btn" onclick="loadRoster()">Retry</button>
            </div>
            
            <!-- ROSTER REVIEW SECTION -->
            <div id="roster-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="roster-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="roster-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="roster-review-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Current Status</th>
                                <th>New Status</th>
                                <th>Effective Date</th>
                            </tr>
                        </thead>
                        <tbody id="roster-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToRoster()">Back</button>
                    <button class="btn" onclick="submitRosterChanges()">Submit</button>
                </div>
            </div>
        </div>

        <!-- OFFICER INFORMATION PAGE -->
        <div id="officer-info" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Officer Information</h2>
            
            <div class="loading-message" id="officer-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading officer information...</p>
            </div>
            
            <div id="officer-content" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="officer-chapter">-</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="officer-table">
                        <thead>
                            <tr>
                                <th>Position</th>
                                <th>Current Officer</th>
                                <th>From Date</th>
                                <th>New Officer</th>
                                <th>Start Date</th>
                            </tr>
                        </thead>
                        <tbody id="officer-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="reviewOfficerChanges()">Review Changes</button>
                </div>
            </div>
            
            <!-- OFFICER REVIEW SECTION -->
            <div id="officer-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="officer-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="officer-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="officer-review-table">
                        <thead>
                            <tr>
                                <th>Position</th>
                                <th>Current Officer</th>
                                <th>New Officer</th>
                                <th>Start Date</th>
                            </tr>
                        </thead>
                        <tbody id="officer-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToOfficers()">Back</button>
                    <button class="btn" onclick="submitOfficerChanges()">Submit</button>
                </div>
            </div>
            
            <div id="officer-error" class="error-message" style="display: none;">
                <p>Error loading officers. Please try again or check your authentication.</p>
                <button class="btn" onclick="loadOfficers()">Retry</button>
            </div>
            
            <!-- OFFICER REVIEW SECTION -->
            <div id="officer-review" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="officer-review-chapter">-</span></p>
                    <p><strong>Changes to Submit:</strong> <span id="officer-review-count">0</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="officer-review-table">
                        <thead>
                            <tr>
                                <th>Position</th>
                                <th>Current Officer</th>
                                <th>New Officer</th>
                                <th>Start Date</th>
                            </tr>
                        </thead>
                        <tbody id="officer-review-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="backToOfficers()">Back</button>
                    <button class="btn" onclick="submitOfficerChanges()">Submit</button>
                </div>
            </div>
        </div>

        <!-- CHAPTER CONTACT INFORMATION PAGE -->
        <div id="contact-info" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Chapter Contact Information</h2>
            
            <div class="loading-message" id="contact-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading chapter contact information...</p>
            </div>
            
            <div id="contact-content" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="contact-chapter">-</span></p>
                </div>
                
                <div class="contact-form">
                    <h3>Postal Address</h3>
                    <div class="form-group">
                        <label for="postal-address-1">Address Line 1:</label>
                        <input type="text" id="postal-address-1" placeholder="Enter address line 1">
                    </div>
                    <div class="form-group">
                        <label for="postal-address-2">Address Line 2:</label>
                        <input type="text" id="postal-address-2" placeholder="Enter address line 2">
                    </div>
                    <div class="form-group">
                        <label for="postal-city">City:</label>
                        <input type="text" id="postal-city" placeholder="Enter city">
                    </div>
                    <div class="form-group">
                        <label for="postal-state">State:</label>
                        <input type="text" id="postal-state" placeholder="Enter state">
                    </div>
                    <div class="form-group">
                        <label for="postal-zip">Zip:</label>
                        <input type="text" id="postal-zip" placeholder="Enter zip code">
                    </div>
                    
                    <h3>Shipping Address</h3>
                    <div class="form-group">
                        <label for="shipping-address-1">Address Line 1:</label>
                        <input type="text" id="shipping-address-1" placeholder="Enter address line 1">
                    </div>
                    <div class="form-group">
                        <label for="shipping-address-2">Address Line 2:</label>
                        <input type="text" id="shipping-address-2" placeholder="Enter address line 2">
                    </div>
                    <div class="form-group">
                        <label for="shipping-city">City:</label>
                        <input type="text" id="shipping-city" placeholder="Enter city">
                    </div>
                    <div class="form-group">
                        <label for="shipping-state">State:</label>
                        <input type="text" id="shipping-state" placeholder="Enter state">
                    </div>
                    <div class="form-group">
                        <label for="shipping-zip">Zip:</label>
                        <input type="text" id="shipping-zip" placeholder="Enter zip code">
                    </div>
                    
                    <h3>Chapter Phone/Email</h3>
                    <div class="form-group">
                        <label for="chapter-phone">Chapter Phone:</label>
                        <input type="tel" id="chapter-phone" placeholder="(123) 456-7890">
                    </div>
                    <div class="form-group">
                        <label for="chapter-email">Chapter Email:</label>
                        <input type="email" id="chapter-email" placeholder="chapter@example.com">
                    </div>
                </div>
                
                <div class="submit-section">
                    <button class="btn" onclick="submitContactChanges()">Update Contact Information</button>
                </div>
            </div>
            
            <div id="contact-error" class="error-message" style="display: none;">
                <p>Error loading contact information. Please try again or check your authentication.</p>
                <button class="btn" onclick="loadContactInfo()">Retry</button>
            </div>
        </div>

        <!-- FEE STATUS PAGE -->
        <div id="fee-status" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Fee Status</h2>
            
            <div class="loading-message" id="fee-loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading fee status information...</p>
            </div>
            
            <div id="fee-content" style="display: none;">
                <div class="candidates-info">
                    <p><strong>Chapter:</strong> <span id="fee-chapter">-</span></p>
                </div>
                
                <div class="candidates-table-container">
                    <table class="candidates-table" id="fee-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Status</th>
                                <th>Candidate Fee Paid</th>
                                <th>Initiate Fee Paid</th>
                            </tr>
                        </thead>
                        <tbody id="fee-tbody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div id="fee-error" class="error-message" style="display: none;">
                <p>Error loading fee status. Please try again or check your authentication.</p>
                <button class="btn" onclick="loadFeeStatus()">Retry</button>
            </div>
        </div>

        <!-- ADMIN PAGE -->
        <div id="admin" class="page">
            <button class="back-btn" onclick="showMainMenu()">← Back to Main Menu</button>
            <h2>Admin & Testing</h2>
            
            <!-- Chapter Information Display -->
            <div class="url-params">
                <h3>Chapter Information</h3>
                <p><strong>SID:</strong> <span id="sid">Not provided</span></p>
                <p><strong>Chapter:</strong> <span id="chapter">Not provided</span></p>
                <p><strong>Officer Name:</strong> <span id="offname">Not provided</span></p>
            </div>
            
            <!-- Allow Skips Configuration -->
            <div class="allow-skips-section">
                <h3>Badge Skip Configuration</h3>
                
                <div class="loading-message" id="allow-skips-loading" style="display: none;">
                    <div class="spinner"></div>
                    <p>Loading configuration...</p>
                </div>
                
                <div id="allow-skips-content" style="display: none;">
                    <div class="allow-skips-control">
                        <label class="checkbox-label">
                            <input type="checkbox" id="allow-skips-checkbox" class="allow-skip-checkbox">
                            <span>Allow badge number skips for <strong id="current-chapter-name">this chapter</strong></span>
                        </label>
                        <p class="help-text">When enabled, initiates can be assigned non-consecutive badge numbers.</p>
                    </div>
                </div>
                
                <div id="allow-skips-error" class="error-message" style="display: none;">
                    <p>Error loading configuration. Please try again.</p>
                    <button class="btn" onclick="loadAllowSkipsConfig()">Retry</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            tokenEndpoint: 'https://oauth2.sky.blackbaud.com/token',
            apiBaseUrl: 'https://api.sky.blackbaud.com/',
            tokenRefreshBuffer: 300000 // 5 minutes in milliseconds
        }

        // REUSABLE QUERY EXECUTION FUNCTIONALITY
        async function executeQuery(queryRequest, resultsFileName = 'query_results') {
            console.log('=== executeQuery() started ===');
            console.log('Results file name:', resultsFileName);

            // Ensure proper structure for the query request
            const fullQueryRequest = {
                ...queryRequest,
                "ux_mode": "Synchronous",
                "output_format": "Json",
                "formatting_mode": "UI",
                "results_file_name": resultsFileName,
                "time_zone_offset_in_minutes": 120
            };

            console.log('Query request built:', JSON.stringify(fullQueryRequest, null, 2));

            // Step 1: Execute the query
            console.log('Executing query via API...');
            const executeResponse = await fetch(`/api/blackbaud?action=query-execute`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(fullQueryRequest)
            });

            console.log('Execute response status:', executeResponse.status);

            if (!executeResponse.ok) {
                const errorText = await executeResponse.text();
                console.error('Execute response error:', errorText);
                throw new Error(`Query execution failed: ${executeResponse.status} - ${errorText}`);
            }

            const executeData = await executeResponse.json();
            console.log('Execute response data:', executeData);
            
            // Get the job ID from the response
            const jobId = executeData.id;
            if (!jobId) {
                console.error('No job ID found in response:', executeData);
                throw new Error('No job ID returned from query execution');
            }

            console.log('Query job ID:', jobId);
            console.log('Initial status:', executeData.status);

            // Step 2: Poll for job completion
            const statusData = await pollJobStatus(jobId);
            
            if (!statusData.sas_uri) {
                throw new Error('Query completed but no results URL provided');
            }

            // Step 3: Fetch the actual results
            console.log('Fetching query results from URL...');
            console.log('SAS URI to fetch:', statusData.sas_uri);
            
            const resultsResponse = await fetch('/api/blackbaud?action=query-results', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ url: statusData.sas_uri })
            });

            if (!resultsResponse.ok) {
                const errorText = await resultsResponse.text();
                console.error('Failed to fetch query results:', resultsResponse.status, errorText);
                throw new Error(`Failed to fetch query results: ${resultsResponse.status} - ${errorText}`);
            }

            const resultsData = await resultsResponse.json();
            console.log('Query results received:', resultsData);
            console.log('Row count:', resultsData.length);
            
            return resultsData;
        }

        async function pollJobStatus(jobId, maxAttempts = 60) {
            console.log('=== pollJobStatus() started ===');
            console.log('Job ID:', jobId);
            
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                console.log(`Polling attempt ${attempts + 1}/${maxAttempts}...`);
                
                const statusResponse = await fetch(`/api/blackbaud?action=query-status&jobId=${jobId}`, {
                    method: 'GET'
                });

                if (!statusResponse.ok) {
                    const errorText = await statusResponse.text();
                    console.error('Status check error:', errorText);
                    throw new Error(`Query status check failed: ${statusResponse.status}`);
                }

                const statusData = await statusResponse.json();
                console.log('Status data:', statusData);

                // Check for completion
                if (statusData.status === 'Completed') {
                    console.log('Query completed successfully');
                    console.log('Row count:', statusData.row_count);
                    return statusData;
                } else if (statusData.status === 'Failed' || statusData.status === 'failed') {
                    throw new Error('Query execution failed: ' + (statusData.message || statusData.error || 'Unknown error'));
                }

                // Wait 1 second before next attempt
                await new Promise(resolve => setTimeout(resolve, 1000));
                attempts++;
            }

            throw new Error('Query execution timeout after ' + maxAttempts + ' seconds');
        }

        // QUERY BUILDERS FOR EACH SUBPAGE
        function buildCandidatesQuery(chapterQuid) {
            return {
                "query": {
                    "advanced_processing_options": {
                        "use_alternate_sql_code_table_fields": false,
                        "use_alternate_sql_multiple_attributes": false
                    },
                    "constituent_filters": {
                        "include_deceased": false,
                        "include_inactive": true,
                        "include_no_valid_addresses": true
                    },
                    "filter_fields": [
                        {
                            "compare_type": "None",
                            "filter_values": ["6985"],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 2217,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [String(chapterQuid)],
                            "operator": "Equals",
                            "query_field_id": 656,
                            "unique_id": "120"
                        }
                    ],
                    "gift_processing_options": {
                        "matching_gift_credit_option": "MatchingGiftCompany",
                        "soft_credit_option": "Donor",
                        "use_gross_amount_for_covenants": false
                    },
                    "select_fields": [
                        {
                            "query_field_id": 349,
                            "user_alias": "ID"
                        },
                        {
                            "query_field_id": 597
                        },
                        {
                            "query_field_id": 2217,
                            "user_alias": "Code"
                        },
                        {
                            "query_field_id": 2216,
                            "user_alias": "CodeID"
                        }
                    ],
                    "sort_fields": [
                        {
                            "query_field_id": 597,
                            "sort_order": "Ascending"
                        }
                    ],
                    "suppress_duplicates": true,
                    "type_id": 18,
                    "sql_generation_mode": "Query"
                }
            };
        }

        function buildInitiatesQuery(chapterQuid, chapterName) {
            return {
                "query": {
                    "advanced_processing_options": {
                        "use_alternate_sql_code_table_fields": false,
                        "use_alternate_sql_multiple_attributes": false
                    },
                    "constituent_filters": {
                        "include_deceased": false,
                        "include_inactive": true,
                        "include_no_valid_addresses": true
                    },
                    "filter_fields": [
                        {
                            "compare_type": "None",
                            "filter_values": ["5707"],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 2217,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [String(chapterQuid)],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 656,
                            "right_parenthesis": false,
                            "unique_id": "120"
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [chapterName],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 4123,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": ["1694"],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 4151,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [],
                            "left_parenthesis": false,
                            "operator": "Blank",
                            "query_field_id": 4148,
                            "right_parenthesis": false
                        }
                    ],
                    "gift_processing_options": {
                        "matching_gift_credit_option": "MatchingGiftCompany",
                        "soft_credit_option": "Donor",
                        "use_gross_amount_for_covenants": false
                    },
                    "select_fields": [
                        {
                            "query_field_id": 349,
                            "user_alias": "ID"
                        },
                        {
                            "query_field_id": 597
                        },
                        {
                            "query_field_id": 656,
                            "unique_id": "38",
                            "user_alias": "Candidate_Ceremony_Date"
                        },
                        {
                            "query_field_id": 2217,
                            "user_alias": "Code"
                        },
                        {
                            "query_field_id": 2216,
                            "user_alias": "CodeID"
                        },
                        {
                            "query_field_id": 4127,
                            "user_alias": "Relation_ID"
                        }
                    ],
                    "sort_fields": [
                        {
                            "query_field_id": 597,
                            "sort_order": "Ascending"
                        }
                    ],
                    "suppress_duplicates": true,
                    "type_id": 18,
                    "sql_generation_mode": "Query"
                }
            };
        }

        function buildTopBadgeQuery(chapterMemcatid) {
            return {
                "query": {
                    "advanced_processing_options": {},
                    "constituent_filters": {
                        "include_deceased": true,
                        "include_inactive": true,
                        "include_no_valid_addresses": true
                    },
                    "filter_fields": [
                        {
                            "compare_type": "None",
                            "filter_values": [String(chapterMemcatid)],
                            "operator": "Equals",
                            "query_field_id": 21792
                        }
                    ],
                    "gift_processing_options": {
                        "matching_gift_credit_option": "MatchingGiftCompany",
                        "soft_credit_option": "Donor"
                    },
                    "select_fields": [
                        {
                            "query_field_id": 21801,
                            "user_alias": "Badge"
                        }
                    ],
                    "sort_fields": [
                        {
                            "query_field_id": 21801,
                            "sort_order": "Descending"
                        }
                    ],
                    "type_id": 18,
                    "sql_generation_mode": "Query"
                }
            };
        }

        function buildRosterQuery(chapterQuid, chapterName) {
            return {
                "query": {
                    "advanced_processing_options": {
                        "use_alternate_sql_code_table_fields": false,
                        "use_alternate_sql_multiple_attributes": false
                    },
                    "constituent_filters": {
                        "include_deceased": false,
                        "include_inactive": true,
                        "include_no_valid_addresses": true
                    },
                    "filter_fields": [
                        {
                            "compare_type": "None",
                            "filter_values": ["5707"],
                            "left_parenthesis": true,
                            "operator": "Equals",
                            "query_field_id": 2217,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [String(chapterQuid)],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 656,
                            "right_parenthesis": false,
                            "unique_id": "120"
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [chapterName],
                            "operator": "Equals",
                            "query_field_id": 4123
                        },
                        {
                            "compare_type": "And",
                            "filter_values": ["1694"],
                            "operator": "Equals",
                            "query_field_id": 4151
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [],
                            "operator": "Blank",
                            "query_field_id": 4148
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [],
                            "operator": "Blank",
                            "query_field_id": 14682,
                            "right_parenthesis": true,
                            "unique_id": "594"
                        },
                        {
                            "compare_type": "Or",
                            "filter_values": ["5708"],
                            "left_parenthesis": true,
                            "operator": "Equals",
                            "query_field_id": 2217
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [String(chapterQuid)],
                            "operator": "Equals",
                            "query_field_id": 656,
                            "unique_id": "120"
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [chapterName],
                            "operator": "Equals",
                            "query_field_id": 4123
                        },
                        {
                            "compare_type": "And",
                            "filter_values": ["1700"],
                            "operator": "Equals",
                            "query_field_id": 4151
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [],
                            "operator": "Blank",
                            "query_field_id": 4148
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [],
                            "operator": "Blank",
                            "query_field_id": 14682,
                            "right_parenthesis": true,
                            "unique_id": "594"
                        }
                    ],
                    "gift_processing_options": {
                        "matching_gift_credit_option": "MatchingGiftCompany",
                        "soft_credit_option": "Donor",
                        "use_gross_amount_for_covenants": false
                    },
                    "select_fields": [
                        {
                            "query_field_id": 349,
                            "user_alias": "ID"
                        },
                        {
                            "query_field_id": 597
                        },
                        {
                            "query_field_id": 2217,
                            "user_alias": "Code"
                        },
                        {
                            "query_field_id": 4125,
                            "user_alias": "From_Date"
                        },
                        {
                            "query_field_id": 4127,
                            "user_alias": "Relation_ID"
                        },
                        {
                            "query_field_id": 656,
                            "unique_id": "37",
                            "user_alias": "Candidate_Fee_Paid"
                        },
                        {
                            "query_field_id": 656,
                            "unique_id": "42",
                            "user_alias": "Initiate_Fee_Paid"
                        },
                        {
                            "query_field_id": 2216,
                            "user_alias": "CodeID"
                        }
                    ],
                    "sort_fields": [
                        {
                            "query_field_id": 2217,
                            "sort_order": "Ascending"
                        },
                        {
                            "query_field_id": 597,
                            "sort_order": "Ascending"
                        }
                    ],
                    "suppress_duplicates": true,
                    "type_id": 18,
                    "sql_generation_mode": "Query"
                }
            };
        }

        function buildOfficerQuery(chapterQuid, chapterName) {
            return {
                "query": {
                    "advanced_processing_options": {
                        "use_alternate_sql_code_table_fields": false,
                        "use_alternate_sql_multiple_attributes": false
                    },
                    "constituent_filters": {
                        "include_deceased": true,
                        "include_inactive": true,
                        "include_no_valid_addresses": true
                    },
                    "filter_fields": [
                        {
                            "compare_type": "None",
                            "filter_values": ["5707", "5708"],
                            "left_parenthesis": false,
                            "operator": "OneOf",
                            "query_field_id": 41225,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [String(chapterQuid)],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 41217,
                            "right_parenthesis": false,
                            "unique_id": "120"
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [chapterName],
                            "left_parenthesis": false,
                            "operator": "Equals",
                            "query_field_id": 40918,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [
                                "2422", "2425", "2408", "2429", "2442", "2423", 
                                "2426", "2510", "2412", "2490", "2432", "2431", 
                                "2427", "2428", "2430", "2424"
                            ],
                            "left_parenthesis": false,
                            "operator": "OneOf",
                            "query_field_id": 40924,
                            "right_parenthesis": false
                        },
                        {
                            "compare_type": "And",
                            "filter_values": [],
                            "left_parenthesis": false,
                            "operator": "Blank",
                            "query_field_id": 40927,
                            "right_parenthesis": false
                        }
                    ],
                    "gift_processing_options": {
                        "matching_gift_credit_option": "MatchingGiftCompany",
                        "soft_credit_option": "Donor",
                        "use_gross_amount_for_covenants": false
                    },
                    "select_fields": [
                        {
                            "query_field_id": 40924,
                            "user_alias": "Position"
                        },
                        {
                            "query_field_id": 40961,
                            "user_alias": "ID"
                        },
                        {
                            "query_field_id": 40967
                        },
                        {
                            "query_field_id": 40906,
                            "user_alias": "From_Date"
                        },
                        {
                            "query_field_id": 40907,
                            "user_alias": "Relation_ID"
                        },
                        {
                            "query_field_id": 104952,
                            "user_alias": "Org_ImpID"
                        }
                    ],
                    "sort_fields": [],
                    "suppress_duplicates": true,
                    "type_id": 40,
                    "sql_generation_mode": "Query"
                }
            };
        }

        function buildChapterContactQuery(chapterName) {
            return {
                "query": {
                    "advanced_processing_options": {},
                    "constituent_filters": {
                        "include_deceased": true,
                        "include_inactive": true,
                        "include_no_valid_addresses": true
                    },
                    "filter_fields": [
                        {
                            "compare_type": "None",
                            "filter_values": [chapterName],
                            "operator": "Equals",
                            "query_field_id": 14300
                        }
                    ],
                    "gift_processing_options": {
                        "matching_gift_credit_option": "MatchingGiftCompany",
                        "soft_credit_option": "Donor"
                    },
                    "select_fields": [
                        {
                            "query_field_id": 349,
                            "user_alias": "ID"
                        },
                        {
                            "query_field_id": 14300,
                            "user_alias": "Name"
                        },
                        {
                            "query_field_id": 863,
                            "unique_id": "2829",
                            "user_alias": "Postal_Address_Line_1"
                        },
                        {
                            "query_field_id": 864,
                            "unique_id": "2829",
                            "user_alias": "Postal_Address_Line_2"
                        },
                        {
                            "query_field_id": 706,
                            "unique_id": "2829",
                            "user_alias": "Postal_City"
                        },
                        {
                            "query_field_id": 790,
                            "unique_id": "2829",
                            "user_alias": "Postal_State"
                        },
                        {
                            "query_field_id": 708,
                            "unique_id": "2829",
                            "user_alias": "Postal_ZIP"
                        },
                        {
                            "query_field_id": 95453,
                            "unique_id": "2829",
                            "user_alias": "Postal_ImpID"
                        },
                        {
                            "query_field_id": 863,
                            "unique_id": "2830",
                            "user_alias": "Shipping_Address_Line_1"
                        },
                        {
                            "query_field_id": 864,
                            "unique_id": "2830",
                            "user_alias": "Shipping_Address_Line_2"
                        },
                        {
                            "query_field_id": 706,
                            "unique_id": "2830",
                            "user_alias": "Shipping_City"
                        },
                        {
                            "query_field_id": 790,
                            "unique_id": "2830",
                            "user_alias": "Shipping_State"
                        },
                        {
                            "query_field_id": 708,
                            "unique_id": "2830",
                            "user_alias": "Shipping_ZIP"
                        },
                        {
                            "query_field_id": 95453,
                            "unique_id": "2830",
                            "user_alias": "Shipping_ImpID"
                        },
                        {
                            "query_field_id": 131226,
                            "unique_id": "1697",
                            "user_alias": "Phone"
                        },
                        {
                            "query_field_id": 131226,
                            "unique_id": "1698",
                            "user_alias": "Email"
                        }
                    ],
                    "sort_fields": [],
                    "type_id": 36,
                    "sql_generation_mode": "Query"
                }
            };
        }

        // CANDIDATES FUNCTIONALITY
        async function loadCandidates() {
            console.log('=== loadCandidates() started ===');
            console.log('Chapter:', appState.chapter);
            
            if (!appState.chapter) {
                showError('candidates-error', 'No chapter specified. Please access this page with a chapter parameter.');
                console.error('No chapter parameter found');
                return;
            }

            // Show loading state
            console.log('Showing loading state...');
            showLoading('candidates-loading');
            hideElement('candidates-content');
            hideElement('candidates-error');

            try {
                // Get chapter QUID
                console.log('Getting chapter QUID for:', appState.chapter);
                const chapterQuid = await getChapterQuid(appState.chapter);
                console.log('Chapter QUID retrieved:', chapterQuid);
                
                if (!chapterQuid) {
                    throw new Error(`Chapter QUID not found for ${appState.chapter}`);
                }

                // Build and execute query
                const queryRequest = buildCandidatesQuery(chapterQuid);
                const resultsData = await executeQuery(queryRequest, 'prospective_candidates');
                
                // Process results
                const candidates = processCandidatesResults(resultsData);
                console.log('Processed candidates:', candidates);
                
                // Display candidates
                displayCandidates(candidates);
                
            } catch (error) {
                console.error('Error loading candidates:', error);
                showError('candidates-error', `Failed to load candidates: ${error.message}`);
            }
        }

        function processCandidatesResults(results) {
            console.log('=== processCandidatesResults() started ===');
            console.log('Raw results:', results);
            
            const candidates = [];
            
            if (Array.isArray(results)) {
                console.log(`Processing ${results.length} candidates`);
                
                results.forEach((row, index) => {
                    console.log(`Row ${index}:`, row);
                    
                    // Truncate codeId to last 5 digits
                    let truncatedCodeId = row.CodeID || '';
                    if (truncatedCodeId && truncatedCodeId.length > 5) {
                        truncatedCodeId = truncatedCodeId.slice(-5);
                    }
                    
                    const candidate = {
                        id: row.ID || row.QRECID || row.id,
                        name: row.Name || row.name || 'N/A',
                        code: row.Code || '',
                        codeId: truncatedCodeId
                    };
                    
                    console.log(`Candidate ${index}:`, candidate);
                    candidates.push(candidate);
                });
            } else {
                console.warn('Unexpected results format:', results);
            }

            console.log(`Total candidates processed: ${candidates.length}`);
            return candidates;
        }

        function processQueryResults(results) {
            console.log('=== processQueryResults() started ===');
            console.log('Raw results:', results);
            
            const candidates = [];
            
            // Handle the JSON format from the query results file
            if (Array.isArray(results)) {
                console.log(`Processing ${results.length} candidates`);
                
                results.forEach((row, index) => {
                    console.log(`Row ${index}:`, row);
                    
                    const candidate = {
                        id: row.ID || row.QRECID || row.id,
                        name: row.Name || row.name || 'N/A'
                    };
                    
                    console.log(`Candidate ${index}:`, candidate);
                    candidates.push(candidate);
                });
            } else if (results && results.rows && Array.isArray(results.rows)) {
                // Handle alternative format if the API returns it differently
                console.log(`Processing ${results.rows.length} rows (alternative format)`);
                
                results.rows.forEach((row, index) => {
                    if (row.values && row.values.length >= 2) {
                        const candidate = {
                            id: row.values[0],
                            name: row.values[1] || 'N/A'
                        };
                        console.log(`Candidate ${index}:`, candidate);
                        candidates.push(candidate);
                    }
                });
            } else {
                console.warn('Unexpected results format:', results);
            }

            console.log(`Total candidates processed: ${candidates.length}`);
            return candidates;
        }

        async function getChapterQuid(chapterName) {
            console.log('=== getChapterQuid() started ===');
            console.log('Looking up QUID for chapter:', chapterName);
            
            // First, try to get from server-side lookup
            try {
                const response = await fetch(`/api/blackbaud?action=chapter-lookup&chapter=${encodeURIComponent(chapterName)}`, {
                    method: 'GET'
                });
                
                console.log('Chapter lookup response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Chapter data received:', data);
                    return data.quid;
                }
            } catch (error) {
                console.warn('Server-side chapter lookup failed:', error);
            }

            // Fallback - this would need to be populated from your chapter-records.js
            console.error('Chapter QUID not found');
            return null;
        }

        async function getChapterData(chapterName) {
            console.log('=== getChapterData() started ===');
            console.log('Looking up data for chapter:', chapterName);
            
            try {
                const response = await fetch(`/api/blackbaud?action=chapter-lookup&chapter=${encodeURIComponent(chapterName)}`, {
                    method: 'GET'
                });
                
                console.log('Chapter lookup response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Chapter data received:', data);
                    return data;
                }
            } catch (error) {
                console.warn('Server-side chapter lookup failed:', error);
            }

            console.error('Chapter data not found');
            return null;
        }

        function displayCandidates(candidates) {
            console.log('=== displayCandidates() started ===');
            console.log('Number of candidates to display:', candidates.length);
            
            const chapterSpan = document.getElementById('candidates-chapter');
            const countSpan = document.getElementById('candidates-count');
            const tbody = document.getElementById('candidates-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = candidates.length;
            
            // Clear existing rows
            if (tbody) {
                tbody.innerHTML = '';
                
                if (candidates.length === 0) {
                    console.log('No candidates found - showing empty state');
                    const row = tbody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 3; // Updated colspan for 3 columns
                    cell.className = 'empty-state-cell';
                    cell.textContent = 'No prospective candidates found for this chapter.';
                } else {
                    console.log('Creating table rows for candidates...');
                    candidates.forEach((candidate, index) => {
                        console.log(`Creating row ${index} for:`, candidate);
                        
                        const row = tbody.insertRow();
                        
                        // Store candidate ID, code, and codeId as data attributes
                        row.dataset.candidateId = candidate.id;
                        row.dataset.code = candidate.code;
                        row.dataset.codeId = candidate.codeId;
                        
                        // Name (single column)
                        const nameCell = row.insertCell();
                        nameCell.textContent = candidate.name || 'N/A';
                        
                        // Approve dropdown
                        const approveCell = row.insertCell();
                        
                        // Create a wrapper div for the select
                        const selectWrapper = document.createElement('div');
                        selectWrapper.className = 'select-wrapper';
                        
                        const approveSelect = document.createElement('select');
                        approveSelect.className = 'approval-select';
                        approveSelect.id = `approval-${index}`;
                        
                        // No Change option (default, blank value)
                        const noChangeOption = document.createElement('option');
                        noChangeOption.value = '';
                        noChangeOption.textContent = 'No Change';
                        noChangeOption.selected = true;
                        approveSelect.appendChild(noChangeOption);
                        
                        const approveOption = document.createElement('option');
                        approveOption.value = 'Candidate';
                        approveOption.textContent = 'Approve';
                        approveSelect.appendChild(approveOption);
                        
                        const disapproveOption = document.createElement('option');
                        disapproveOption.value = 'Disapproved';
                        disapproveOption.textContent = 'Disapprove';
                        approveSelect.appendChild(disapproveOption);
                        
                        const unknownOption = document.createElement('option');
                        unknownOption.value = 'Unknown';
                        unknownOption.textContent = 'Person Unknown';
                        approveSelect.appendChild(unknownOption);
                        
                        // Add change event listener
                        approveSelect.addEventListener('change', function() {
                            handleApprovalChange(index, this.value);
                        });
                        
                        selectWrapper.appendChild(approveSelect);
                        approveCell.appendChild(selectWrapper);
                        
                        // Candidate Ceremony Date
                        const dateCell = row.insertCell();
                        const dateInput = document.createElement('input');
                        dateInput.type = 'date';
                        dateInput.className = 'date-input';
                        dateInput.id = `ceremony-date-${index}`;
                        dateInput.disabled = true; // Initially disabled
                        
                        // Set max date to today
                        const today = new Date();
                        dateInput.max = today.toISOString().split('T')[0];
                        
                        dateCell.appendChild(dateInput);
                    });
                }
            }
            
            // Show content
            console.log('Hiding loading state and showing content...');
            hideElement('candidates-loading');
            showElement('candidates-content');
            
            // Trigger resize
            resizeIframe();
            console.log('=== displayCandidates() completed ===');
        }

        function handleApprovalChange(index, approvalValue) {
            const dateInput = document.getElementById(`ceremony-date-${index}`);
            if (!dateInput) return;

            if (approvalValue === 'Candidate') {
                // Enable date picker for approved candidates
                dateInput.disabled = false;
                dateInput.value = ''; // Clear any default value
            } else if (approvalValue === '' || !approvalValue) {
                // No Change selected - disable and clear date
                dateInput.disabled = true;
                dateInput.value = '';
            } else {
                // Disapproved or Unknown - disable date picker and set to today's date in Eastern Time
                dateInput.disabled = true;
                
                // Get today's date in Eastern Time
                const easternTime = new Date().toLocaleString("en-US", {timeZone: "America/New_York"});
                const easternDate = new Date(easternTime);
                
                // Format as YYYY-MM-DD for input field
                const year = easternDate.getFullYear();
                const month = String(easternDate.getMonth() + 1).padStart(2, '0');
                const day = String(easternDate.getDate()).padStart(2, '0');
                
                dateInput.value = `${year}-${month}-${day}`;
            }
        }

        function submitCandidateVerifications() {
            // Get all candidate data from the review table
            const tbody = document.getElementById('candidates-review-tbody');
            if (!tbody) {
                showStatus('No review data found. Please return to the main screen.', 'error');
                return;
            }
            
            const rows = tbody.querySelectorAll('tr');
            const candidates = [];
            
            // Collect all candidate data from review table
            rows.forEach((row) => {
                const nameCell = row.cells[0];
                const statusCell = row.cells[1];
                const dateCell = row.cells[2];
                
                // Store the candidate data that was saved during review
                const candidateData = row.candidateData;
                
                if (candidateData) {
                    candidates.push({
                        id: candidateData.id,
                        code: candidateData.code,
                        codeId: candidateData.codeId,
                        name: nameCell.textContent,
                        approval: getApprovalValueFromText(statusCell.textContent),
                        ceremonyDate: getDateFromFormattedText(dateCell.textContent)
                    });
                }
            });
            
            if (candidates.length === 0) {
                showStatus('No candidates found for submission.', 'error');
                return;
            }
            
            // Start the submission process
            submitCandidateChanges(candidates);
        }
        
        function getApprovalValueFromText(text) {
            if (text === 'Approve') return 'Candidate';
            if (text === 'Disapprove') return 'Disapproved';
            if (text === 'Person Unknown') return 'Unknown';
            return '';
        }
        
        function getDateFromFormattedText(formattedDate) {
            // Convert mm/dd/yyyy back to yyyy-mm-dd
            const parts = formattedDate.split('/');
            if (parts.length === 3) {
                return `${parts[2]}-${parts[0].padStart(2, '0')}-${parts[1].padStart(2, '0')}`;
            }
            return '';
        }
        
        async function submitCandidateChanges(candidates) {
            console.log('=== submitCandidateChanges() started ===');
            console.log('Submitting changes for', candidates.length, 'candidates');
            
            // Disable submit button to prevent double submission
            const submitButton = document.querySelector('#candidates-review .submit-section button[onclick="submitCandidateVerifications()"]');
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.textContent = 'Processing...';
            }
            
            try {
                // Get chapter data for csid and feid
                const chapterData = await getChapterData(appState.chapter);
                if (!chapterData) {
                    throw new Error('Could not retrieve chapter data');
                }
                
                let successCount = 0;
                let errorCount = 0;
                const errors = [];
                
                // Process each candidate
                for (const candidate of candidates) {
                    try {
                        await processCandidateSubmission(candidate, chapterData);
                        successCount++;
                    } catch (error) {
                        console.error(`Error processing candidate ${candidate.name}:`, error);
                        errorCount++;
                        errors.push(`${candidate.name}: ${error.message}`);
                    }
                }
                
                // Show results
                if (errorCount === 0) {
                    showStatus(`Successfully processed all ${successCount} candidate(s).`, 'success');
                    // Hide review section and reload candidates
                    hideElement('candidates-review');
                    loadCandidates();
                } else {
                    showStatus(`Processed ${successCount} candidate(s) with ${errorCount} error(s). Check console for details.`, 'error');
                    console.error('Submission errors:', errors);
                }
                
            } catch (error) {
                console.error('Fatal error during submission:', error);
                showStatus(`Submission failed: ${error.message}`, 'error');
            } finally {
                // Re-enable submit button
                if (submitButton) {
                    submitButton.disabled = false;
                    submitButton.textContent = 'Submit';
                }
            }
        }
        
        async function processCandidateSubmission(candidate, chapterData) {
            console.log(`Processing candidate: ${candidate.name}`);
            
            // Step 1: Parse ceremony date - Fix timezone issue
            const [year, month, day] = candidate.ceremonyDate.split('-');
            const startDate = {
                d: parseInt(day, 10),
                m: parseInt(month, 10),
                y: parseInt(year, 10)
            };
            
            // Get current date in Eastern Time for the date field
            const easternTime = new Date().toLocaleString("en-US", {timeZone: "America/New_York"});
            const easternDate = new Date(easternTime);
            const currentDateISO = `${easternDate.getFullYear()}-${String(easternDate.getMonth() + 1).padStart(2, '0')}-${String(easternDate.getDate()).padStart(2, '0')}T00:00:00.000-0000`;
            
            // Step 2: Delete existing constituent code
            console.log(`Deleting code: ${candidate.codeId}`);
            const deleteResponse = await fetch(`/api/blackbaud?action=delete-constituent-code&endpoint=/constituent/v1/constituentcodes/${candidate.codeId}`, {
                method: 'DELETE'
            });
            
            if (!deleteResponse.ok) {
                const error = await deleteResponse.json();
                throw new Error(`Failed to delete code: ${error.error}`);
            }
            
            // Step 3: Create new constituent code
            console.log(`Creating new code: ${candidate.approval}`);
            const codeData = {
                constituent_id: candidate.id,
                description: candidate.approval,
                start: startDate
            };
            
            const createCodeResponse = await fetch('/api/blackbaud?action=create-constituent-code', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(codeData)
            });
            
            if (!createCodeResponse.ok) {
                const error = await createCodeResponse.json();
                throw new Error(`Failed to create code: ${error.error}`);
            }
            
            // Step 4: Create constituent note
            console.log('Creating note');
            const noteData = {
                constituent_id: candidate.id,
                date: startDate,
                text: `Changed by ${appState.offname || 'Unknown'}`,
                type: "CodeLog"
            };
            
            const createNoteResponse = await fetch('/api/blackbaud?action=create-constituent-note', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(noteData)
            });
            
            if (!createNoteResponse.ok) {
                const error = await createNoteResponse.json();
                throw new Error(`Failed to create note: ${error.error}`);
            }
            
            // Step 5: If approved (Candidate), continue with relationship and custom fields
            if (candidate.approval === 'Candidate') {
                console.log('Candidate approved - creating relationship and custom fields');
                
                // Step 6: Create constituent relationship
                const relationshipData = {
                    comment: `Added by ${appState.offname || 'Unknown'}`,
                    constituent_id: candidate.id,
                    is_organization_contact: false,
                    is_primary_business: false,
                    is_spouse: false,
                    reciprocal_type: "Candidate",
                    relation_id: chapterData.csid,
                    start: startDate,
                    type: "Collegiate Chapter"
                };
                
                const createRelationshipResponse = await fetch('/api/blackbaud?action=create-constituent-relationship', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(relationshipData)
                });
                
                if (!createRelationshipResponse.ok) {
                    const error = await createRelationshipResponse.json();
                    throw new Error(`Failed to create relationship: ${error.error}`);
                }
                
                // Step 7: Create custom fields
                // Format the ceremony date properly for custom field
                const ceremonyDateFormatted = `${candidate.ceremonyDate}T00:00:00.000-0000`;
                
                const customFields = [
                    {
                        category: "Candidate - Ceremony Date",
                        date: currentDateISO,
                        value: ceremonyDateFormatted
                    },
                    {
                        category: "Candidate - Fee Paid",
                        comment: chapterData.feid,
                        date: currentDateISO,
                        value: ""
                    },
                    {
                        category: "Candidate - Complete Date",
                        date: currentDateISO,
                        value: ""
                    },
                    {
                        category: "Sigma Nu Code",
                        value: "Candidate"
                    }
                ];
                
                const createFieldsResponse = await fetch('/api/blackbaud?action=create-custom-fields', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        constituentId: candidate.id,
                        fields: customFields
                    })
                });
                
                if (!createFieldsResponse.ok) {
                    const error = await createFieldsResponse.json();
                    throw new Error(`Failed to create custom fields: ${error.error}`);
                }
            }
            
            console.log(`Successfully processed candidate: ${candidate.name}`);
        }

        // UTILITY FUNCTIONS
        function showLoading(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.style.display = 'block';
        }

        function hideElement(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.style.display = 'none';
        }

        function showElement(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.style.display = 'block';
        }

        function showError(elementId, message) {
            hideElement('candidates-loading');
            hideElement('candidates-content');
            hideElement('initiates-loading');
            hideElement('initiates-content');
            const errorElement = document.getElementById(elementId);
            if (errorElement) {
                const errorText = errorElement.querySelector('p');
                if (errorText) errorText.textContent = message;
                errorElement.style.display = 'block';
            }
        };

        // Application state
        let appState = {
            accessToken: null,
            tokenType: 'Bearer',
            expiresAt: null,
            refreshTimer: null,
            clientId: null,
            clientSecret: null,
            subscriptionKey: null,
            sid: null,
            chapter: null,
            sts: null,
            offname: null,
            currentPage: 'main',
            lastBadgeNumber: null,
            allowedSkips: {} // Store allowed skips configuration
        };

        // SIMPLE NAVIGATION FUNCTIONS
        function showPage(pageId) {
            // Check authorization before showing any page
            if (!isAuthorized()) {
                return;
            }
            
            // Hide main menu
            document.getElementById('main-menu').style.display = 'none';
            
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });
            
            // Show selected page
            document.getElementById(pageId).style.display = 'block';
            appState.currentPage = pageId;
            
            // Load page-specific data
            if (pageId === 'verify-candidates') {
                loadCandidates();
            } else if (pageId === 'verify-initiates') {
                loadInitiates();
            } else if (pageId === 'roster-info') {
                loadRoster();
            } else if (pageId === 'officer-info') {
                loadOfficers();
            } else if (pageId === 'contact-info') {
                loadContactInfo();
            } else if (pageId === 'fee-status') {
                loadFeeStatus();
            } else if (pageId === 'admin') {
                loadAllowSkipsConfig();
            }
            
            // Notify parent of height change
            resizeIframe();
        }

        function showMainMenu() {
            // Check authorization
            if (!isAuthorized()) {
                return;
            }
            
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });
            
            // Show main menu
            document.getElementById('main-menu').style.display = 'block';
            appState.currentPage = 'main';
            
            // Notify parent of height change
            resizeIframe();
        }

        // Authorization check function
        function isAuthorized() {
            return appState.sts !== null && ['0', '1', '2'].includes(appState.sts);
        }

        // Apply security level based on sts parameter
        function applySecurityLevel() {
            const mainMenu = document.getElementById('main-menu');
            const unauthorized = document.getElementById('unauthorized');
            
            // If no sts parameter or invalid value, show unauthorized
            if (appState.sts === null || !['0', '1', '2'].includes(appState.sts)) {
                mainMenu.style.display = 'none';
                unauthorized.style.display = 'block';
                
                // Hide all pages
                document.querySelectorAll('.page').forEach(page => {
                    page.style.display = 'none';
                });
                
                resizeIframe();
                return;
            }
            
            // Show main menu
            unauthorized.style.display = 'none';
            mainMenu.style.display = 'block';
            
            // Hide all buttons first
            const buttons = {
                'btn-verify-candidates': false,
                'btn-verify-initiates': false,
                'btn-roster-info': false,
                'btn-officer-info': false,
                'btn-contact-info': false,
                'btn-fee-status': false,
                'btn-admin': false
            };
            
            // Show buttons based on sts value
            switch(appState.sts) {
                case '0': // Show all buttons including Admin
                    Object.keys(buttons).forEach(btn => buttons[btn] = true);
                    break;
                case '1': // Show all buttons except Admin
                    Object.keys(buttons).forEach(btn => {
                        buttons[btn] = btn !== 'btn-admin';
                    });
                    break;
                case '2': // Show only Fee Status (Treasurer) button
                    buttons['btn-fee-status'] = true;
                    break;
            }
            
            // Apply visibility
            Object.keys(buttons).forEach(btnId => {
                const button = document.getElementById(btnId);
                if (button) {
                    button.style.display = buttons[btnId] ? 'block' : 'none';
                }
            });
            
            resizeIframe();
        }

        // Function to communicate height to parent iframe
        function resizeIframe() {
            // Wait for DOM to settle, then force recalculation
            setTimeout(() => {
                // Force the body to shrink to its content
                document.body.style.height = 'auto';
                
                // Force a reflow
                document.body.offsetHeight;
                
                // Get the actual content height
                const container = document.querySelector('.container');
                const containerHeight = container ? container.offsetHeight : 0;
                const bodyPadding = 40; // 20px top + 20px bottom
                const totalHeight = containerHeight + bodyPadding;
                
                // Send height to parent window
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'resize',
                        height: totalHeight
                    }, '*');
                }
            }, 150);
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            parseURLParameters();
            loadStoredCredentials();
            checkTokenStatus();
            
            // Initial iframe resize
            resizeIframe();
        });

        function parseURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const sid = urlParams.get('sid') || urlParams.get('SID') || 'Not provided';
            const chapter = urlParams.get('chapter') || urlParams.get('Chapter') || 'Not provided';
            const sts = urlParams.get('sts') || urlParams.get('STS');
            const offname = urlParams.get('offname') || urlParams.get('OFFNAME') || 'Not provided';
            
            // Store in application state
            appState.sid = sid !== 'Not provided' ? sid : null;
            appState.chapter = chapter !== 'Not provided' ? chapter : null;
            appState.sts = sts;
            appState.offname = offname !== 'Not provided' ? offname : null;
            
            const sidElement = document.getElementById('sid');
            const chapterElement = document.getElementById('chapter');
            const offnameElement = document.getElementById('offname');
            if (sidElement) sidElement.textContent = sid;
            if (chapterElement) chapterElement.textContent = chapter;
            if (offnameElement) offnameElement.textContent = offname;
            
            // Apply security based on sts parameter
            applySecurityLevel();
        }

        function loadStoredCredentials() {
            // In a real application, you'd load these from secure server-side storage
            // For demo purposes, we'll use the form inputs
        }

        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
                statusDiv.style.display = 'block';
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        function updateTokenInfo() {
            const tokenInfo = document.getElementById('tokenInfo');
            const accessTokenSpan = document.getElementById('accessToken');
            const tokenTypeSpan = document.getElementById('tokenType');
            const expiresAtSpan = document.getElementById('expiresAt');
            const tokenStatusSpan = document.getElementById('tokenStatus');
            
            if (appState.accessToken && tokenInfo) {
                tokenInfo.style.display = 'block';
                if (accessTokenSpan) accessTokenSpan.textContent = appState.accessToken.substring(0, 20) + '...';
                if (tokenTypeSpan) tokenTypeSpan.textContent = appState.tokenType;
                if (expiresAtSpan) expiresAtSpan.textContent = appState.expiresAt ? new Date(appState.expiresAt).toLocaleString() : 'Unknown';
                if (tokenStatusSpan) tokenStatusSpan.textContent = isTokenValid() ? 'Active' : 'Expired';
            } else if (tokenInfo) {
                tokenInfo.style.display = 'none';
            }
        }

        function isTokenValid() {
            console.log('Checking token validity...');
            console.log('Access Token exists:', !!appState.accessToken);
            console.log('Expires At:', appState.expiresAt);
            console.log('Current Time:', new Date().getTime());
            console.log('Time until expiration:', appState.expiresAt ? (appState.expiresAt - new Date().getTime()) / 1000 + ' seconds' : 'N/A');
            
            const valid = appState.accessToken && appState.expiresAt && new Date().getTime() < appState.expiresAt;
            console.log('Token is valid:', valid);
            return valid;
        }

        async function authenticate() {
            showStatus('Authenticating with server...', 'info');
            
            try {
                const response = await fetch('/api/blackbaud?action=auth', {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    throw new Error(`Authentication failed: ${response.status}`);
                }
                
                const tokenData = await response.json();
                
                // Store token information
                appState.accessToken = tokenData.access_token;
                appState.tokenType = tokenData.token_type || 'Bearer';
                appState.expiresAt = new Date().getTime() + (tokenData.expires_in * 1000);
                
                // Schedule token refresh
                scheduleTokenRefresh(tokenData.expires_in);
                
                updateTokenInfo();
                showStatus('Authentication successful!', 'success');
                
            } catch (error) {
                console.error('Authentication error:', error);
                showStatus(`Authentication failed: ${error.message}`, 'error');
            }
        }

        function scheduleTokenRefresh(expiresInSeconds) {
            // Clear existing timer
            if (appState.refreshTimer) {
                clearTimeout(appState.refreshTimer);
            }
            
            // Schedule refresh 5 minutes before expiration
            const refreshTime = (expiresInSeconds * 1000) - CONFIG.tokenRefreshBuffer;
            
            appState.refreshTimer = setTimeout(() => {
                refreshToken();
            }, refreshTime);
        }

        async function refreshToken() {
            if (!appState.clientId || !appState.clientSecret) {
                showStatus('Missing credentials for token refresh', 'error');
                return;
            }
            
            try {
                const response = await fetch(CONFIG.tokenEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': `Basic ${btoa(appState.clientId + ':' + appState.clientSecret)}`
                    },
                    body: 'grant_type=client_credentials'
                });
                
                if (!response.ok) {
                    throw new Error(`Token refresh failed: ${response.status}`);
                }
                
                const tokenData = await response.json();
                
                appState.accessToken = tokenData.access_token;
                appState.expiresAt = new Date().getTime() + (tokenData.expires_in * 1000);
                
                scheduleTokenRefresh(tokenData.expires_in);
                updateTokenInfo();
                
                console.log('Token refreshed successfully');
                
            } catch (error) {
                console.error('Token refresh error:', error);
                showStatus('Token refresh failed. Please re-authenticate.', 'error');
            }
        }

        function checkTokenStatus() {
            // Check token validity every minute
            setInterval(() => {
                updateTokenInfo();
            }, 60000);
        }

        async function makeApiCall(endpoint, resultElementId) {
            if (!isTokenValid()) {
                showStatus('No valid token. Please authenticate first.', 'error');
                return;
            }
            
            const responseArea = document.getElementById(resultElementId);
            if (responseArea) {
                responseArea.style.display = 'block';
                responseArea.textContent = 'Making API call...';
            }
            
            try {
                // Add SID and Chapter to endpoint if available
                let fullEndpoint = endpoint;
                if (appState.sid && endpoint.includes('{sid}')) {
                    fullEndpoint = fullEndpoint.replace('{sid}', appState.sid);
                }
                if (appState.chapter && endpoint.includes('{chapter}')) {
                    fullEndpoint = fullEndpoint.replace('{chapter}', appState.chapter);
                }
                
                const response = await fetch(`/api/blackbaud?action=api&endpoint=${encodeURIComponent(fullEndpoint)}&token=${appState.accessToken}`, {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    throw new Error(`API call failed: ${response.status}`);
                }
                
                const data = await response.json();
                if (responseArea) {
                    responseArea.textContent = JSON.stringify(data, null, 2);
                }
                showStatus('API call successful!', 'success');
                
            } catch (error) {
                console.error('API call error:', error);
                if (responseArea) {
                    responseArea.textContent = `Error: ${error.message}`;
                }
                showStatus(`API call failed: ${error.message}`, 'error');
            }
        }
        
        // INITIATES FUNCTIONALITY
        async function loadInitiates() {
            console.log('=== loadInitiates() started ===');
            console.log('Chapter:', appState.chapter);
            
            if (!appState.chapter) {
                showError('initiates-error', 'No chapter specified. Please access this page with a chapter parameter.');
                console.error('No chapter parameter found');
                return;
            }

            // Show loading state
            console.log('Showing loading state...');
            showLoading('initiates-loading');
            hideElement('initiates-content');
            hideElement('initiates-error');

            try {
                // Check if skips are allowed for this chapter
                const skipValidationDisabled = await checkAllowedSkips();
                
                // Get full chapter data (includes both quid and memcatid)
                console.log('Getting chapter data for:', appState.chapter);
                const chapterData = await getChapterData(appState.chapter);
                console.log('Chapter data retrieved:', chapterData);
                
                if (!chapterData || !chapterData.quid) {
                    throw new Error(`Chapter data not found for ${appState.chapter}`);
                }

                // Execute both queries in parallel
                const [initiatesResults, topBadgeResults] = await Promise.all([
                    // Query 1: Get initiates
                    executeQuery(buildInitiatesQuery(chapterData.quid, appState.chapter), 'candidates'),
                    // Query 2: Get top badge (only if memcatid exists)
                    chapterData.memcatid ? executeQuery(buildTopBadgeQuery(chapterData.memcatid), 'topbadge') : Promise.resolve(null)
                ]);
                
                // Process initiates results
                const initiates = processInitiatesResults(initiatesResults);
                console.log('Processed initiates:', initiates);
                
                // Process top badge if available
                let topBadgeNumber = null;
                if (topBadgeResults && Array.isArray(topBadgeResults) && topBadgeResults.length > 0) {
                    const fullBadge = topBadgeResults[0].Badge;
                    // Extract last 4 characters and convert to number to remove leading zeros
                    const last4 = fullBadge.slice(-4);
                    topBadgeNumber = parseInt(last4, 10);
                    console.log('Top badge found:', fullBadge, '-> processed to:', topBadgeNumber);
                }
                
                // Store in app state for validation
                appState.lastBadgeNumber = topBadgeNumber;
                appState.skipValidationDisabled = skipValidationDisabled;
                
                // Display initiates with top badge info
                displayInitiates(initiates, topBadgeNumber);
                
            } catch (error) {
                console.error('Error loading initiates:', error);
                showError('initiates-error', `Failed to load initiates: ${error.message}`);
            }
        }

        function processInitiatesResults(results) {
            console.log('=== processInitiatesResults() started ===');
            console.log('Raw results:', results);
            
            const initiates = [];
            
            if (Array.isArray(results)) {
                console.log(`Processing ${results.length} initiates`);
                
                results.forEach((row, index) => {
                    console.log(`Row ${index}:`, row);
                    
                    // Truncate codeId to last 5 digits
                    let truncatedCodeId = row.CodeID || '';
                    if (truncatedCodeId && truncatedCodeId.length > 5) {
                        truncatedCodeId = truncatedCodeId.slice(-5);
                    }
                    
                    // Truncate relationId to last 7 digits
                    let truncatedRelationId = row.Relation_ID || '';
                    if (truncatedRelationId && truncatedRelationId.length > 7) {
                        truncatedRelationId = truncatedRelationId.slice(-7);
                    }
                    
                    const initiate = {
                        id: row.ID || row.QRECID || row.id,
                        name: row.Name || row.name || 'N/A',
                        candidateCeremonyDate: row.Candidate_Ceremony_Date || '',
                        code: row.Code || '',
                        codeId: truncatedCodeId,
                        relationId: truncatedRelationId
                    };
                    
                    console.log(`Initiate ${index}:`, initiate);
                    initiates.push(initiate);
                });
            } else {
                console.warn('Unexpected results format:', results);
            }

            console.log(`Total initiates processed: ${initiates.length}`);
            return initiates;
        }

        function displayInitiates(initiates, topBadgeNumber = null) {
            console.log('=== displayInitiates() started ===');
            console.log('Number of initiates to display:', initiates.length);
            console.log('Top badge number:', topBadgeNumber);
            
            const chapterSpan = document.getElementById('initiates-chapter');
            const countSpan = document.getElementById('initiates-count');
            const tbody = document.getElementById('initiates-tbody');
            const lastBadgeInfo = document.getElementById('last-badge-info');
            const lastBadgeNumber = document.getElementById('last-badge-number');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = initiates.length;
            
            // Display top badge if available
            if (topBadgeNumber !== null && lastBadgeInfo && lastBadgeNumber) {
                lastBadgeNumber.textContent = topBadgeNumber.toString();
                lastBadgeInfo.style.display = 'block';
            }
            
            // Clear existing rows
            if (tbody) {
                tbody.innerHTML = '';
                
                if (initiates.length === 0) {
                    console.log('No initiates found - showing empty state');
                    const row = tbody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 5; // 5 columns for initiates table
                    cell.className = 'empty-state-cell';
                    cell.textContent = 'No prospective initiates found for this chapter.';
                } else {
                    console.log('Creating table rows for initiates...');
                    initiates.forEach((initiate, index) => {
                        console.log(`Creating row ${index} for:`, initiate);
                        
                        const row = tbody.insertRow();
                        
                        // Store initiate ID, code, codeId, and relationId as data attributes
                        row.dataset.initiateId = initiate.id;
                        row.dataset.code = initiate.code;
                        row.dataset.codeId = initiate.codeId;
                        row.dataset.relationId = initiate.relationId;
                        
                        // Initiated checkbox
                        const initiatedCell = row.insertCell();
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'initiated-checkbox';
                        checkbox.id = `initiated-${index}`;
                        checkbox.addEventListener('change', function() {
                            handleInitiatedChange(index, this.checked);
                        });
                        initiatedCell.appendChild(checkbox);
                        
                        // Name
                        const nameCell = row.insertCell();
                        nameCell.textContent = initiate.name || 'N/A';
                        
                        // Candidate Ceremony Date
                        const candidateDateCell = row.insertCell();
                        if (initiate.candidateCeremonyDate) {
                            // Format date for display if it exists
                            candidateDateCell.textContent = formatDateForDisplay(initiate.candidateCeremonyDate);
                        } else {
                            candidateDateCell.textContent = 'N/A';
                        }
                        
                        // Initiate Ceremony Date
                        const initiateDateCell = row.insertCell();
                        const dateInput = document.createElement('input');
                        dateInput.type = 'date';
                        dateInput.className = 'date-input';
                        dateInput.id = `initiate-ceremony-date-${index}`;
                        dateInput.disabled = true; // Initially disabled
                        
                        // Set max date to today
                        const today = new Date();
                        dateInput.max = today.toISOString().split('T')[0];
                        
                        // Set min date to day after candidate ceremony date if it exists
                        if (initiate.candidateCeremonyDate) {
                            const candidateDate = parseDate(initiate.candidateCeremonyDate);
                            if (candidateDate) {
                                candidateDate.setDate(candidateDate.getDate() + 1);
                                dateInput.min = candidateDate.toISOString().split('T')[0];
                            }
                        }
                        
                        initiateDateCell.appendChild(dateInput);
                        
                        // Badge Number
                        const badgeCell = row.insertCell();
                        const badgeInput = document.createElement('input');
                        badgeInput.type = 'number';
                        badgeInput.className = 'badge-input';
                        badgeInput.id = `badge-number-${index}`;
                        badgeInput.disabled = true; // Initially disabled
                        
                        // Set min based on last badge number
                        if (topBadgeNumber !== null) {
                            badgeInput.min = (topBadgeNumber + 1).toString();
                        } else {
                            badgeInput.min = '1';
                        }
                        badgeInput.max = '9999';
                        badgeInput.placeholder = '0000';
                        
                        // Add validation for badge number
                        badgeInput.addEventListener('input', function() {
                            // Restrict to 4 digits
                            if (this.value.length > 4) {
                                this.value = this.value.slice(0, 4);
                            }
                            
                            // Validate against last badge number
                            if (appState.lastBadgeNumber !== null && this.value) {
                                const enteredNumber = parseInt(this.value, 10);
                                if (enteredNumber <= appState.lastBadgeNumber) {
                                    this.setCustomValidity(`Badge number must be greater than ${appState.lastBadgeNumber}`);
                                    this.reportValidity();
                                } else {
                                    this.setCustomValidity('');
                                }
                            }
                        });
                        
                        badgeCell.appendChild(badgeInput);
                    });
                }
            }
            
            // Show content
            console.log('Hiding loading state and showing content...');
            hideElement('initiates-loading');
            showElement('initiates-content');
            
            // Trigger resize
            resizeIframe();
            console.log('=== displayInitiates() completed ===');
        }

        function handleInitiatedChange(index, isChecked) {
            const dateInput = document.getElementById(`initiate-ceremony-date-${index}`);
            const badgeInput = document.getElementById(`badge-number-${index}`);
            
            if (dateInput) {
                dateInput.disabled = !isChecked;
                if (!isChecked) {
                    dateInput.value = '';
                }
            }
            
            if (badgeInput) {
                badgeInput.disabled = !isChecked;
                if (!isChecked) {
                    badgeInput.value = '';
                }
            }
        }

        function formatDateForDisplay(dateString) {
            if (!dateString) return 'N/A';
            
            // Handle various date formats
            const date = parseDate(dateString);
            if (date && !isNaN(date)) {
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const year = date.getFullYear();
                return `${month}/${day}/${year}`;
            }
            
            return dateString; // Return as-is if parsing fails
        }

        function parseDate(dateString) {
            if (!dateString) return null;
            
            // Try parsing various formats
            // Format: MM/DD/YYYY
            if (dateString.includes('/')) {
                const parts = dateString.split('/');
                if (parts.length === 3) {
                    return new Date(parts[2], parts[0] - 1, parts[1]);
                }
            }
            
            // Format: YYYY-MM-DD
            if (dateString.includes('-')) {
                return new Date(dateString);
            }
            
            // Try default parsing
            return new Date(dateString);
        }

        function submitInitiateVerifications() {
            // Get all initiate data
            const initiates = [];
            const tbody = document.getElementById('initiates-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const initiateId = row.dataset.initiateId;
                    if (initiateId) {
                        const checkbox = document.getElementById(`initiated-${index}`);
                        const dateInput = document.getElementById(`initiate-ceremony-date-${index}`);
                        const badgeInput = document.getElementById(`badge-number-${index}`);
                        
                        if (checkbox && checkbox.checked && dateInput && badgeInput) {
                            // Format date as mm/dd/yyyy for display
                            let formattedDate = '';
                            if (dateInput.value) {
                                const [year, month, day] = dateInput.value.split('-');
                                formattedDate = `${month}/${day}/${year}`;
                            }
                            
                            initiates.push({
                                id: initiateId,
                                initiated: true,
                                ceremonyDate: dateInput.value,
                                ceremonyDateFormatted: formattedDate,
                                badgeNumber: badgeInput.value
                            });
                        }
                    }
                });
            }
            
            if (initiates.length === 0) {
                showStatus('No initiates have been selected. Please check at least one initiate.', 'error');
                return;
            }
            
            // Validate that all selected initiates have ceremony dates and badge numbers
            const incomplete = initiates.filter(i => !i.ceremonyDate || !i.badgeNumber);
            
            if (incomplete.length > 0) {
                showStatus(`Please ensure all selected initiates have ceremony dates and badge numbers. ${incomplete.length} initiate(s) missing required information.`, 'error');
                return;
            }
            
            // Validate badge numbers are greater than last badge
            if (appState.lastBadgeNumber !== null) {
                const invalidBadges = initiates.filter(i => {
                    const badgeNum = parseInt(i.badgeNumber, 10);
                    return badgeNum <= appState.lastBadgeNumber;
                });
                
                if (invalidBadges.length > 0) {
                    showStatus(`Badge numbers must be greater than ${appState.lastBadgeNumber}. ${invalidBadges.length} initiate(s) have invalid badge numbers.`, 'error');
                    return;
                }
            }
            
            // For now, just show what would be submitted
            console.log('Initiate verifications to submit:', initiates);
            showStatus(`Ready to submit ${initiates.length} initiate verification(s). (Submit functionality coming soon)`, 'info');
        }
        
        async function getRosterInfo() {
            const rosterType = document.getElementById('rosterType').value;
            
            // This would need to be customized based on your specific API structure
            let endpoint = '/constituents';
            
            // Add filtering based on roster type and chapter info
            if (appState.chapter) {
                endpoint += `?chapter=${appState.chapter}`;
            }
            
            await makeApiCall(endpoint, 'rosterResult');
        }
        
        // ROSTER FUNCTIONALITY
        async function loadRoster() {
            console.log('=== loadRoster() started ===');
            console.log('Chapter:', appState.chapter);
            
            if (!appState.chapter) {
                showRosterError('No chapter specified. Please access this page with a chapter parameter.');
                console.error('No chapter parameter found');
                return;
            }

            // Show loading state
            console.log('Showing loading state...');
            showLoading('roster-loading');
            hideElement('roster-content');
            hideElement('roster-error');

            try {
                // Get chapter QUID
                console.log('Getting chapter QUID for:', appState.chapter);
                const chapterQuid = await getChapterQuid(appState.chapter);
                console.log('Chapter QUID retrieved:', chapterQuid);
                
                if (!chapterQuid) {
                    throw new Error(`Chapter QUID not found for ${appState.chapter}`);
                }

                // Build and execute query
                const queryRequest = buildRosterQuery(chapterQuid, appState.chapter);
                const resultsData = await executeQuery(queryRequest, 'roster');
                
                // Process results
                const roster = processRosterResults(resultsData);
                console.log('Processed roster:', roster);
                
                // Display roster
                displayRoster(roster);
                
            } catch (error) {
                console.error('Error loading roster:', error);
                showRosterError(`Failed to load roster: ${error.message}`);
            }
        }

        function processRosterResults(results) {
            console.log('=== processRosterResults() started ===');
            console.log('Raw results:', results);
            
            const roster = [];
            
            if (Array.isArray(results)) {
                console.log(`Processing ${results.length} roster members`);
                
                results.forEach((row, index) => {
                    console.log(`Row ${index}:`, row);
                    
                    // Truncate codeId to last 5 digits
                    let truncatedCodeId = row.CodeID || '';
                    if (truncatedCodeId && truncatedCodeId.length > 5) {
                        truncatedCodeId = truncatedCodeId.slice(-5);
                    }
                    
                    // Truncate relationId to last 7 digits
                    let truncatedRelationId = row.Relation_ID || '';
                    if (truncatedRelationId && truncatedRelationId.length > 7) {
                        truncatedRelationId = truncatedRelationId.slice(-7);
                    }
                    
                    const member = {
                        id: row.ID || row.QRECID || row.id,
                        name: row.Name || row.name || 'N/A',
                        status: row.Code || row.Status || 'Unknown',
                        fromDate: row.From_Date || '',
                        relationId: truncatedRelationId,
                        candidateFeePaid: row.Candidate_Fee_Paid || 'No',
                        initiateFeePaid: row.Initiate_Fee_Paid || 'No',
                        codeId: truncatedCodeId
                    };
                    
                    console.log(`Member ${index}:`, member);
                    roster.push(member);
                });
            } else {
                console.warn('Unexpected results format:', results);
            }

            console.log(`Total roster members processed: ${roster.length}`);
            return roster;
        }

        function displayRoster(roster) {
            console.log('=== displayRoster() started ===');
            console.log('Number of members to display:', roster.length);
            
            const chapterSpan = document.getElementById('roster-chapter');
            const candidatesCountSpan = document.getElementById('roster-candidates-count');
            const initiatesCountSpan = document.getElementById('roster-initiates-count');
            const tbody = document.getElementById('roster-tbody');
            
            // Count candidates and initiates
            let candidatesCount = 0;
            let initiatesCount = 0;
            roster.forEach(member => {
                if (member.status === '5707' || member.status === 'Candidate') {
                    candidatesCount++;
                } else if (member.status === '5708' || member.status === 'Initiate') {
                    initiatesCount++;
                }
            });
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (candidatesCountSpan) candidatesCountSpan.textContent = candidatesCount;
            if (initiatesCountSpan) initiatesCountSpan.textContent = initiatesCount;
            
            // Clear existing rows
            if (tbody) {
                tbody.innerHTML = '';
                
                if (roster.length === 0) {
                    console.log('No members found - showing empty state');
                    const row = tbody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 5;
                    cell.className = 'empty-state-cell';
                    cell.textContent = 'No members found for this chapter.';
                } else {
                    console.log('Creating table rows for roster...');
                    roster.forEach((member, index) => {
                        console.log(`Creating row ${index} for:`, member);
                        
                        const row = tbody.insertRow();
                        
                        // Store member data as attributes
                        row.dataset.memberId = member.id;
                        row.dataset.memberStatus = member.status;
                        row.dataset.candidateFeePaid = member.candidateFeePaid;
                        row.dataset.initiateFeePaid = member.initiateFeePaid;
                        row.dataset.codeId = member.codeId;
                        row.dataset.relationId = member.relationId;
                        
                        // Name
                        const nameCell = row.insertCell();
                        nameCell.textContent = member.name || 'N/A';
                        
                        // Current Status
                        const currentCell = row.insertCell();
                        currentCell.textContent = member.status === '5707' || member.status === 'Candidate' ? 'Candidate' : 
                                                member.status === '5708' || member.status === 'Initiate' ? 'Initiate' : 
                                                member.status;
                        
                        // From Date
                        const fromDateCell = row.insertCell();
                        fromDateCell.textContent = formatDateForDisplay(member.fromDate);
                        
                        // Status dropdown
                        const statusCell = row.insertCell();
                        
                        // Determine if dropdown should be shown
                        const isCandidate = member.status === '5707' || member.status === 'Candidate';
                        const isInitiate = member.status === '5708' || member.status === 'Initiate';
                        const candidateFeeUnpaid = isCandidate && member.candidateFeePaid !== 'Yes';
                        const feesUnpaid = isInitiate && (member.candidateFeePaid !== 'Yes' || member.initiateFeePaid !== 'Yes');
                        
                        if (candidateFeeUnpaid) {
                            statusCell.textContent = '-';
                            statusCell.title = 'Candidate Fee Unpaid';
                            statusCell.style.cursor = 'help';
                        } else {
                            const selectWrapper = document.createElement('div');
                            selectWrapper.className = 'select-wrapper';
                            
                            const statusSelect = document.createElement('select');
                            statusSelect.className = 'status-select';
                            statusSelect.id = `status-${index}`;
                            
                            // Default option
                            const defaultOption = document.createElement('option');
                            defaultOption.value = '';
                            defaultOption.textContent = 'No Change';
                            defaultOption.selected = true;
                            statusSelect.appendChild(defaultOption);
                            
                            if (isCandidate) {
                                // Candidate options
                                const depledgeOption = document.createElement('option');
                                depledgeOption.value = 'De-Pledge';
                                depledgeOption.textContent = 'De-pledge';
                                statusSelect.appendChild(depledgeOption);
                            } else if (isInitiate) {
                                if (feesUnpaid) {
                                    // Limited options for unpaid fees
                                    selectWrapper.title = 'Fee(s) Unpaid';
                                    
                                    const suspendedOption = document.createElement('option');
                                    suspendedOption.value = 'Proposed Suspended';
                                    suspendedOption.textContent = 'Proposed Suspended';
                                    statusSelect.appendChild(suspendedOption);
                                    
                                    const expelledOption = document.createElement('option');
                                    expelledOption.value = 'Proposed Expelled';
                                    expelledOption.textContent = 'Proposed Expelled';
                                    statusSelect.appendChild(expelledOption);
                                } else {
                                    // Full options for paid fees
                                    const alumniLeftOption = document.createElement('option');
                                    alumniLeftOption.value = 'Alumni (Left School)';
                                    alumniLeftOption.textContent = 'Alumni (Left-School)';
                                    statusSelect.appendChild(alumniLeftOption);
                                    
                                    const alumniGradOption = document.createElement('option');
                                    alumniGradOption.value = 'Alumni';
                                    alumniGradOption.textContent = 'Alumni (Graduated)';
                                    statusSelect.appendChild(alumniGradOption);
                                    
                                    const suspendedOption = document.createElement('option');
                                    suspendedOption.value = 'Proposed Suspended';
                                    suspendedOption.textContent = 'Proposed Suspended';
                                    statusSelect.appendChild(suspendedOption);
                                    
                                    const expelledOption = document.createElement('option');
                                    expelledOption.value = 'Proposed Expelled';
                                    expelledOption.textContent = 'Proposed Expelled';
                                    statusSelect.appendChild(expelledOption);
                                }
                            }
                            
                            // Add change event listener
                            statusSelect.addEventListener('change', function() {
                                handleRosterStatusChange(index, this.value);
                            });
                            
                            selectWrapper.appendChild(statusSelect);
                            statusCell.appendChild(selectWrapper);
                        }
                        
                        // Date picker
                        const dateCell = row.insertCell();
                        const dateInput = document.createElement('input');
                        dateInput.type = 'date';
                        dateInput.className = 'date-input';
                        dateInput.id = `roster-date-${index}`;
                        dateInput.disabled = true; // Initially disabled
                        
                        // Set max date to today
                        const today = new Date();
                        dateInput.max = today.toISOString().split('T')[0];
                        
                        // Set min date to day after from date if it exists
                        if (member.fromDate) {
                            const fromDate = parseDate(member.fromDate);
                            if (fromDate) {
                                fromDate.setDate(fromDate.getDate() + 1);
                                dateInput.min = fromDate.toISOString().split('T')[0];
                            }
                        }
                        
                        dateCell.appendChild(dateInput);
                    });
                }
            }
            
            // Show content
            console.log('Hiding loading state and showing content...');
            hideElement('roster-loading');
            showElement('roster-content');
            
            // Trigger resize
            resizeIframe();
            console.log('=== displayRoster() completed ===');
        }

        function handleRosterStatusChange(index, statusValue) {
            const dateInput = document.getElementById(`roster-date-${index}`);
            if (!dateInput) return;

            if (statusValue && statusValue !== '') {
                // Enable date picker when status is selected
                dateInput.disabled = false;
                dateInput.value = ''; // Clear any default value
            } else {
                // Disable and clear date when "No Change" is selected
                dateInput.disabled = true;
                dateInput.value = '';
            }
        }

        function showRosterError(message) {
            hideElement('roster-loading');
            hideElement('roster-content');
            const errorElement = document.getElementById('roster-error');
            if (errorElement) {
                const errorText = errorElement.querySelector('p');
                if (errorText) errorText.textContent = message;
                errorElement.style.display = 'block';
            }
        }

        function submitRosterChanges() {
            // For now, just show what would be submitted
            console.log('Roster changes to submit from review');
            showStatus('Submit functionality coming soon', 'info');
        }

        // ROSTER REVIEW FUNCTIONS
        function reviewRosterChanges() {
            // Get all roster changes
            const changes = [];
            const tbody = document.getElementById('roster-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const memberId = row.dataset.memberId;
                    if (memberId) {
                        const statusSelect = document.getElementById(`status-${index}`);
                        const dateInput = document.getElementById(`roster-date-${index}`);
                        const nameCell = row.cells[0];
                        const currentStatusCell = row.cells[1];
                        
                        if (statusSelect && statusSelect.value && statusSelect.value !== '' && dateInput) {
                            const selectedOption = statusSelect.options[statusSelect.selectedIndex];
                            
                            changes.push({
                                id: memberId,
                                name: nameCell.textContent,
                                currentStatus: currentStatusCell.textContent,
                                newStatus: statusSelect.value,
                                newStatusText: selectedOption.textContent,
                                effectiveDate: dateInput.value,
                                effectiveDateFormatted: dateInput.value ? formatDateForDisplay(dateInput.value) : '',
                                codeId: row.dataset.codeId,
                                relationId: row.dataset.relationId
                            });
                        }
                    }
                });
            }
            
            if (changes.length === 0) {
                const message = 'No changes have been made. Please select a status for at least one member.';
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Validate that all changes have dates
            const incomplete = changes.filter(c => !c.effectiveDate);
            
            if (incomplete.length > 0) {
                const message = `Please ensure all status changes have effective dates. ${incomplete.length} member(s) missing date.`;
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Display review table
            displayRosterReview(changes);
        }

        function displayRosterReview(changes) {
            const chapterSpan = document.getElementById('roster-review-chapter');
            const countSpan = document.getElementById('roster-review-count');
            const tbody = document.getElementById('roster-review-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = changes.length;
            
            if (tbody) {
                tbody.innerHTML = '';
                
                changes.forEach(change => {
                    const row = tbody.insertRow();
                    
                    // Name
                    const nameCell = row.insertCell();
                    nameCell.textContent = change.name;
                    
                    // Current Status
                    const currentCell = row.insertCell();
                    currentCell.textContent = change.currentStatus;
                    
                    // New Status
                    const newStatusCell = row.insertCell();
                    newStatusCell.textContent = change.newStatusText;
                    
                    // Effective Date
                    const dateCell = row.insertCell();
                    dateCell.textContent = change.effectiveDateFormatted;
                });
            }
            
            // Hide main content, show review
            hideElement('roster-content');
            showElement('roster-review');
            resizeIframe();
        }

        function backToRoster() {
            hideElement('roster-review');
            showElement('roster-content');
            resizeIframe();
        }
        
        async function getOfficerInfo() {
            const officerPosition = document.getElementById('officerPosition').value;
            
            // This would need to be customized based on your specific API structure
            let endpoint = '/constituents';
            
            // Add filtering for officers
            if (appState.chapter) {
                endpoint += `?chapter=${appState.chapter}&role=officer`;
            }
            
            await makeApiCall(endpoint, 'officerResult');
        }
        
        // OFFICER FUNCTIONALITY
        async function loadOfficers() {
            console.log('=== loadOfficers() started ===');
            console.log('Chapter:', appState.chapter);
            
            if (!appState.chapter) {
                showOfficerError('No chapter specified. Please access this page with a chapter parameter.');
                console.error('No chapter parameter found');
                return;
            }

            // Show loading state
            console.log('Showing loading state...');
            showLoading('officer-loading');
            hideElement('officer-content');
            hideElement('officer-error');

            try {
                // Get chapter QUID
                console.log('Getting chapter QUID for:', appState.chapter);
                const chapterQuid = await getChapterQuid(appState.chapter);
                console.log('Chapter QUID retrieved:', chapterQuid);
                
                if (!chapterQuid) {
                    throw new Error(`Chapter QUID not found for ${appState.chapter}`);
                }

                // Execute both queries in parallel
                const [rosterResults, officerResults] = await Promise.all([
                    // Query 1: Get roster for member list
                    executeQuery(buildRosterQuery(chapterQuid, appState.chapter), 'roster_for_officers'),
                    // Query 2: Get current officers
                    executeQuery(buildOfficerQuery(chapterQuid, appState.chapter), 'officers')
                ]);
                
                // Process results
                const roster = processRosterResults(rosterResults);
                const officers = processOfficerResults(officerResults);
                
                console.log('Processed roster:', roster);
                console.log('Processed officers:', officers);
                
                // Display officers
                displayOfficers(officers, roster);
                
            } catch (error) {
                console.error('Error loading officers:', error);
                showOfficerError(`Failed to load officers: ${error.message}`);
            }
        }

        function processOfficerResults(results) {
            console.log('=== processOfficerResults() started ===');
            console.log('Raw results:', results);
            
            const officers = [];
            
            if (Array.isArray(results)) {
                console.log(`Processing ${results.length} officers`);
                
                results.forEach((row, index) => {
                    console.log(`Row ${index}:`, row);
                    
                    // Truncate relationId to last 7 digits
                    let truncatedRelationId = row.Relation_ID || '';
                    if (truncatedRelationId && truncatedRelationId.length > 7) {
                        truncatedRelationId = truncatedRelationId.slice(-7);
                    }
                    
                    const officer = {
                        position: row.Position || 'Unknown',
                        id: row.ID || row.QRECID || row.id,
                        name: row.Name || row.name || 'N/A',
                        fromDate: row.From_Date || '',
                        relationId: truncatedRelationId,
                        orgImpId: row.Org_ImpID || ''
                    };
                    
                    console.log(`Officer ${index}:`, officer);
                    officers.push(officer);
                });
            } else {
                console.warn('Unexpected results format:', results);
            }

            console.log(`Total officers processed: ${officers.length}`);
            return officers;
        }

        // Define all 16 officer positions in order
        const OFFICER_POSITIONS = [
            'Alumni Relations',
            'Chaplain',
            'Commander',
            'House Manager',
            'LEAD Chairman',
            'Lt. Commander',
            'Marshal',
            'Philanthropy/Community Relations',
            'Recorder',
            'Recruitment Chairman',
            'Reporter',
            'Risk Reduction Officer',
            'Scholarship Chairman',
            'Sentinel',
            'Social Chairman',
            'Treasurer'
        ];

        function displayOfficers(officers, roster) {
            console.log('=== displayOfficers() started ===');
            console.log('Number of officers:', officers.length);
            console.log('Number of roster members:', roster.length);
            
            const chapterSpan = document.getElementById('officer-chapter');
            const tbody = document.getElementById('officer-tbody');
            
            // Process officers to handle duplicates - keep only the latest
            const officerMap = {};
            officers.forEach(officer => {
                const existingOfficer = officerMap[officer.position];
                if (!existingOfficer || compareFromDates(officer.fromDate, existingOfficer.fromDate) > 0) {
                    officerMap[officer.position] = officer;
                }
            });
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            
            // Clear existing rows
            if (tbody) {
                tbody.innerHTML = '';
                
                // Create rows for all 16 positions
                OFFICER_POSITIONS.forEach((position, index) => {
                    console.log(`Creating row for position: ${position}`);
                    
                    const row = tbody.insertRow();
                    const currentOfficer = officerMap[position];
                    
                    // Store position data
                    row.dataset.position = position;
                    if (currentOfficer) {
                        row.dataset.currentOfficerId = currentOfficer.id;
                        row.dataset.currentOfficerName = currentOfficer.name;
                        row.dataset.fromDate = currentOfficer.fromDate;
                        row.dataset.relationId = currentOfficer.relationId;
                    }
                    
                    // Position
                    const positionCell = row.insertCell();
                    positionCell.textContent = position;
                    
                    // Current Officer
                    const currentCell = row.insertCell();
                    currentCell.textContent = currentOfficer ? currentOfficer.name : '-';
                    
                    // From Date
                    const fromDateCell = row.insertCell();
                    fromDateCell.textContent = currentOfficer ? formatDateForDisplay(currentOfficer.fromDate) : '-';
                    
                    // New Officer dropdown
                    const newOfficerCell = row.insertCell();
                    const selectWrapper = document.createElement('div');
                    selectWrapper.className = 'select-wrapper';
                    
                    const officerSelect = document.createElement('select');
                    officerSelect.className = 'officer-select';
                    officerSelect.id = `new-officer-${index}`;
                    
                    // Default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = 'No Change';
                    defaultOption.selected = true;
                    officerSelect.appendChild(defaultOption);
                    
                    // Add all roster members as options
                    roster.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member.id;
                        option.textContent = member.name;
                        option.dataset.memberId = member.id;
                        officerSelect.appendChild(option);
                    });
                    
                    // Add change event listener
                    officerSelect.addEventListener('change', function() {
                        handleOfficerChange(index, this.value);
                    });
                    
                    selectWrapper.appendChild(officerSelect);
                    newOfficerCell.appendChild(selectWrapper);
                    
                    // Start Date picker
                    const startDateCell = row.insertCell();
                    const dateInput = document.createElement('input');
                    dateInput.type = 'date';
                    dateInput.className = 'date-input';
                    dateInput.id = `officer-start-date-${index}`;
                    dateInput.disabled = true; // Initially disabled
                    
                    // Set max date to today
                    const today = new Date();
                    dateInput.max = today.toISOString().split('T')[0];
                    
                    // Set min date to day after current officer's from date if exists
                    if (currentOfficer && currentOfficer.fromDate) {
                        const fromDate = parseDate(currentOfficer.fromDate);
                        if (fromDate) {
                            fromDate.setDate(fromDate.getDate() + 1);
                            dateInput.min = fromDate.toISOString().split('T')[0];
                        }
                    }
                    
                    startDateCell.appendChild(dateInput);
                });
            }
            
            // Show content
            console.log('Hiding loading state and showing content...');
            hideElement('officer-loading');
            showElement('officer-content');
            
            // Trigger resize
            resizeIframe();
            console.log('=== displayOfficers() completed ===');
        }

        function compareFromDates(date1, date2) {
            const d1 = parseDate(date1);
            const d2 = parseDate(date2);
            if (!d1) return -1;
            if (!d2) return 1;
            return d1.getTime() - d2.getTime();
        }

        function handleOfficerChange(index, newOfficerId) {
            const dateInput = document.getElementById(`officer-start-date-${index}`);
            if (!dateInput) return;

            if (newOfficerId && newOfficerId !== '') {
                // Enable date picker when officer is selected
                dateInput.disabled = false;
                dateInput.value = ''; // Clear any default value
            } else {
                // Disable and clear date when "No Change" is selected
                dateInput.disabled = true;
                dateInput.value = '';
            }
        }

        function showOfficerError(message) {
            hideElement('officer-loading');
            hideElement('officer-content');
            const errorElement = document.getElementById('officer-error');
            if (errorElement) {
                const errorText = errorElement.querySelector('p');
                if (errorText) errorText.textContent = message;
                errorElement.style.display = 'block';
            }
        }

        function submitOfficerChanges() {
            // For now, just show what would be submitted
            console.log('Officer changes to submit from review');
            showStatus('Submit functionality coming soon', 'info');
        }

        // OFFICER REVIEW FUNCTIONS
        function reviewOfficerChanges() {
            // Get all officer changes
            const changes = [];
            const tbody = document.getElementById('officer-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const position = row.dataset.position;
                    if (position) {
                        const officerSelect = document.getElementById(`new-officer-${index}`);
                        const dateInput = document.getElementById(`officer-start-date-${index}`);
                        const currentOfficerCell = row.cells[1];
                        
                        if (officerSelect && officerSelect.value && officerSelect.value !== '' && dateInput) {
                            const selectedOption = officerSelect.options[officerSelect.selectedIndex];
                            
                            changes.push({
                                position: position,
                                currentOfficer: currentOfficerCell.textContent === '-' ? 'None' : currentOfficerCell.textContent,
                                currentOfficerId: row.dataset.currentOfficerId || null,
                                newOfficerId: officerSelect.value,
                                newOfficerName: selectedOption.textContent,
                                startDate: dateInput.value,
                                startDateFormatted: dateInput.value ? formatDateForDisplay(dateInput.value) : '',
                                relationId: row.dataset.relationId || null
                            });
                        }
                    }
                });
            }
            
            if (changes.length === 0) {
                const message = 'No changes have been made. Please select a new officer for at least one position.';
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Validate that all changes have start dates
            const incomplete = changes.filter(c => !c.startDate);
            
            if (incomplete.length > 0) {
                const message = `Please ensure all officer changes have start dates. ${incomplete.length} position(s) missing date.`;
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Display review table
            displayOfficerReview(changes);
        }

        function displayOfficerReview(changes) {
            const chapterSpan = document.getElementById('officer-review-chapter');
            const countSpan = document.getElementById('officer-review-count');
            const tbody = document.getElementById('officer-review-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = changes.length;
            
            if (tbody) {
                tbody.innerHTML = '';
                
                changes.forEach(change => {
                    const row = tbody.insertRow();
                    
                    // Position
                    const positionCell = row.insertCell();
                    positionCell.textContent = change.position;
                    
                    // Current Officer
                    const currentCell = row.insertCell();
                    currentCell.textContent = change.currentOfficer;
                    
                    // New Officer
                    const newOfficerCell = row.insertCell();
                    newOfficerCell.textContent = change.newOfficerName;
                    
                    // Start Date
                    const dateCell = row.insertCell();
                    dateCell.textContent = change.startDateFormatted;
                });
            }
            
            // Hide main content, show review
            hideElement('officer-content');
            showElement('officer-review');
            resizeIframe();
        }

        function backToOfficers() {
            hideElement('officer-review');
            showElement('officer-content');
            resizeIframe();
        }
        
        async function getContactInfo() {
            // This would need to be customized based on your specific API structure
            let endpoint = '/constituents';
            
            if (appState.chapter) {
                endpoint += `?chapter=${appState.chapter}&contact_info=true`;
            }
            
            await makeApiCall(endpoint, 'contactResult');
        }
        
        // CONTACT INFORMATION FUNCTIONALITY
        async function loadContactInfo() {
            console.log('=== loadContactInfo() started ===');
            console.log('Chapter:', appState.chapter);
            
            if (!appState.chapter) {
                showContactError('No chapter specified. Please access this page with a chapter parameter.');
                console.error('No chapter parameter found');
                return;
            }

            // Show loading state
            console.log('Showing loading state...');
            showLoading('contact-loading');
            hideElement('contact-content');
            hideElement('contact-error');

            try {
                // Build and execute query (doesn't need QUID, just chapter name)
                const queryRequest = buildChapterContactQuery(appState.chapter);
                const resultsData = await executeQuery(queryRequest, 'chapter_contact');
                
                // Process results
                const contactInfo = processContactResults(resultsData);
                console.log('Processed contact info:', contactInfo);
                
                // Display contact info
                displayContactInfo(contactInfo);
                
            } catch (error) {
                console.error('Error loading contact info:', error);
                showContactError(`Failed to load contact information: ${error.message}`);
            }
        }

        function processContactResults(results) {
            console.log('=== processContactResults() started ===');
            console.log('Raw results:', results);
            
            let contactInfo = {
                id: '',
                name: '',
                postalAddress1: '',
                postalAddress2: '',
                postalCity: '',
                postalState: '',
                postalZip: '',
                postalImpId: '',
                shippingAddress1: '',
                shippingAddress2: '',
                shippingCity: '',
                shippingState: '',
                shippingZip: '',
                shippingImpId: '',
                phone: '',
                email: ''
            };
            
            if (Array.isArray(results) && results.length > 0) {
                const row = results[0]; // Should only be one result
                console.log('Contact data:', row);
                
                contactInfo = {
                    id: row.ID || '',
                    name: row.Name || '',
                    postalAddress1: row.Postal_Address_Line_1 || '',
                    postalAddress2: row.Postal_Address_Line_2 || '',
                    postalCity: row.Postal_City || '',
                    postalState: row.Postal_State || '',
                    postalZip: row.Postal_ZIP || '',
                    postalImpId: row.Postal_ImpID || '',
                    shippingAddress1: row.Shipping_Address_Line_1 || '',
                    shippingAddress2: row.Shipping_Address_Line_2 || '',
                    shippingCity: row.Shipping_City || '',
                    shippingState: row.Shipping_State || '',
                    shippingZip: row.Shipping_ZIP || '',
                    shippingImpId: row.Shipping_ImpID || '',
                    phone: row.Phone || '',
                    email: row.Email || ''
                };
            } else {
                console.warn('No contact information found');
            }

            console.log('Processed contact info:', contactInfo);
            return contactInfo;
        }

        function displayContactInfo(contactInfo) {
            console.log('=== displayContactInfo() started ===');
            console.log('Contact info to display:', contactInfo);
            
            const chapterSpan = document.getElementById('contact-chapter');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            
            // Store IDs for later use
            appState.contactId = contactInfo.id;
            appState.postalImpId = contactInfo.postalImpId;
            appState.shippingImpId = contactInfo.shippingImpId;
            
            // Populate form fields
            document.getElementById('postal-address-1').value = contactInfo.postalAddress1;
            document.getElementById('postal-address-2').value = contactInfo.postalAddress2;
            document.getElementById('postal-city').value = contactInfo.postalCity;
            document.getElementById('postal-state').value = contactInfo.postalState;
            document.getElementById('postal-zip').value = contactInfo.postalZip;
            
            document.getElementById('shipping-address-1').value = contactInfo.shippingAddress1;
            document.getElementById('shipping-address-2').value = contactInfo.shippingAddress2;
            document.getElementById('shipping-city').value = contactInfo.shippingCity;
            document.getElementById('shipping-state').value = contactInfo.shippingState;
            document.getElementById('shipping-zip').value = contactInfo.shippingZip;
            
            const phoneInput = document.getElementById('chapter-phone');
            const emailInput = document.getElementById('chapter-email');
            
            phoneInput.value = contactInfo.phone;
            emailInput.value = contactInfo.email;
            
            // Add phone formatting on input
            phoneInput.addEventListener('input', function(e) {
                let value = e.target.value.replace(/\D/g, '');
                let formattedValue = '';
                
                if (value.length > 0) {
                    if (value.length <= 3) {
                        formattedValue = `(${value}`;
                    } else if (value.length <= 6) {
                        formattedValue = `(${value.slice(0, 3)}) ${value.slice(3)}`;
                    } else {
                        formattedValue = `(${value.slice(0, 3)}) ${value.slice(3, 6)}-${value.slice(6, 10)}`;
                    }
                }
                
                e.target.value = formattedValue;
            });
            
            // Add email validation
            emailInput.addEventListener('blur', function(e) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (e.target.value && !emailRegex.test(e.target.value)) {
                    e.target.setCustomValidity('Please enter a valid email address');
                    e.target.reportValidity();
                } else {
                    e.target.setCustomValidity('');
                }
            });
            
            // Show content
            console.log('Hiding loading state and showing content...');
            hideElement('contact-loading');
            showElement('contact-content');
            
            // Trigger resize
            resizeIframe();
            console.log('=== displayContactInfo() completed ===');
        }

        function showContactError(message) {
            hideElement('contact-loading');
            hideElement('contact-content');
            const errorElement = document.getElementById('contact-error');
            if (errorElement) {
                const errorText = errorElement.querySelector('p');
                if (errorText) errorText.textContent = message;
                errorElement.style.display = 'block';
            }
        }

        function submitContactChanges() {
            // Validate email
            const emailInput = document.getElementById('chapter-email');
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (emailInput.value && !emailRegex.test(emailInput.value)) {
                showStatus('Please enter a valid email address.', 'error');
                emailInput.focus();
                return;
            }
            
            // Validate phone format
            const phoneInput = document.getElementById('chapter-phone');
            const phoneRegex = /^\(\d{3}\) \d{3}-\d{4}$/;
            if (phoneInput.value && !phoneRegex.test(phoneInput.value)) {
                showStatus('Please enter phone in format: (123) 456-7890', 'error');
                phoneInput.focus();
                return;
            }
            
            // Collect all contact data
            const contactData = {
                id: appState.contactId,
                postalAddress: {
                    impId: appState.postalImpId,
                    address1: document.getElementById('postal-address-1').value,
                    address2: document.getElementById('postal-address-2').value,
                    city: document.getElementById('postal-city').value,
                    state: document.getElementById('postal-state').value,
                    zip: document.getElementById('postal-zip').value
                },
                shippingAddress: {
                    impId: appState.shippingImpId,
                    address1: document.getElementById('shipping-address-1').value,
                    address2: document.getElementById('shipping-address-2').value,
                    city: document.getElementById('shipping-city').value,
                    state: document.getElementById('shipping-state').value,
                    zip: document.getElementById('shipping-zip').value
                },
                phone: document.getElementById('chapter-phone').value,
                email: document.getElementById('chapter-email').value
            };
            
            // For now, just show what would be submitted
            console.log('Contact information to submit:', contactData);
            showStatus('Ready to submit contact information updates. (Submit functionality coming soon)', 'info');
        }
        
        async function getFeeStatus() {
            const memberId = document.getElementById('memberId').value;
            
            // This would need to be customized based on your specific API structure
            let endpoint = memberId ? `/constituents/${memberId}/fees` : '/fees';
            
            if (appState.chapter && !memberId) {
                endpoint += `?chapter=${appState.chapter}`;
            }
            
            await makeApiCall(endpoint, 'feeResult');
        }
        
        // FEE STATUS FUNCTIONALITY
        async function loadFeeStatus() {
            console.log('=== loadFeeStatus() started ===');
            console.log('Chapter:', appState.chapter);
            
            if (!appState.chapter) {
                showFeeError('No chapter specified. Please access this page with a chapter parameter.');
                console.error('No chapter parameter found');
                return;
            }

            // Show loading state
            console.log('Showing loading state...');
            showLoading('fee-loading');
            hideElement('fee-content');
            hideElement('fee-error');

            try {
                // Get chapter QUID
                console.log('Getting chapter QUID for:', appState.chapter);
                const chapterQuid = await getChapterQuid(appState.chapter);
                console.log('Chapter QUID retrieved:', chapterQuid);
                
                if (!chapterQuid) {
                    throw new Error(`Chapter QUID not found for ${appState.chapter}`);
                }

                // Reuse roster query
                const queryRequest = buildRosterQuery(chapterQuid, appState.chapter);
                const resultsData = await executeQuery(queryRequest, 'fee_status');
                
                // Process results (same as roster)
                const feeData = processRosterResults(resultsData);
                console.log('Processed fee data:', feeData);
                
                // Display fee status
                displayFeeStatus(feeData);
                
            } catch (error) {
                console.error('Error loading fee status:', error);
                showFeeError(`Failed to load fee status: ${error.message}`);
            }
        }

        function displayFeeStatus(feeData) {
            console.log('=== displayFeeStatus() started ===');
            console.log('Number of members to display:', feeData.length);
            
            const chapterSpan = document.getElementById('fee-chapter');
            const tbody = document.getElementById('fee-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            
            // Clear existing rows
            if (tbody) {
                tbody.innerHTML = '';
                
                if (feeData.length === 0) {
                    console.log('No members found - showing empty state');
                    const row = tbody.insertRow();
                    const cell = row.insertCell();
                    cell.colSpan = 4;
                    cell.className = 'empty-state-cell';
                    cell.textContent = 'No members found for this chapter.';
                } else {
                    console.log('Creating table rows for fee status...');
                    feeData.forEach((member, index) => {
                        console.log(`Creating row ${index} for:`, member);
                        
                        const row = tbody.insertRow();
                        
                        // Name
                        const nameCell = row.insertCell();
                        nameCell.textContent = member.name || 'N/A';
                        
                        // Current Status
                        const statusCell = row.insertCell();
                        statusCell.textContent = member.status === '5707' || member.status === 'Candidate' ? 'Candidate' : 
                                               member.status === '5708' || member.status === 'Initiate' ? 'Initiate' : 
                                               member.status;
                        
                        // Candidate Fee Paid
                        const candidateFeeCell = row.insertCell();
                        candidateFeeCell.textContent = member.candidateFeePaid || 'No';
                        if (member.candidateFeePaid === 'Yes') {
                            candidateFeeCell.style.color = '#28a745';
                            candidateFeeCell.style.fontWeight = 'bold';
                        } else {
                            candidateFeeCell.style.color = '#dc3545';
                        }
                        
                        // Initiate Fee Paid
                        const initiateFeeCell = row.insertCell();
                        initiateFeeCell.textContent = member.initiateFeePaid || 'No';
                        if (member.initiateFeePaid === 'Yes') {
                            initiateFeeCell.style.color = '#28a745';
                            initiateFeeCell.style.fontWeight = 'bold';
                        } else {
                            initiateFeeCell.style.color = '#dc3545';
                        }
                    });
                }
            }
            
            // Show content
            console.log('Hiding loading state and showing content...');
            hideElement('fee-loading');
            showElement('fee-content');
            
            // Trigger resize
            resizeIframe();
            console.log('=== displayFeeStatus() completed ===');
        }

        function showFeeError(message) {
            hideElement('fee-loading');
            hideElement('fee-content');
            const errorElement = document.getElementById('fee-error');
            if (errorElement) {
                const errorText = errorElement.querySelector('p');
                if (errorText) errorText.textContent = message;
                errorElement.style.display = 'block';
            }
        }

        // CANDIDATES REVIEW FUNCTIONS
        function reviewCandidateChanges() {
            // Get all candidate changes
            const changes = [];
            const tbody = document.getElementById('candidates-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const candidateId = row.dataset.candidateId;
                    if (candidateId) {
                        const approvalSelect = document.getElementById(`approval-${index}`);
                        const dateInput = document.getElementById(`ceremony-date-${index}`);
                        const nameCell = row.cells[0];
                        
                        if (approvalSelect && dateInput && approvalSelect.value !== '') {
                            changes.push({
                                id: candidateId,
                                code: row.dataset.code,
                                codeId: row.dataset.codeId,
                                name: nameCell.textContent,
                                approval: approvalSelect.value,
                                ceremonyDate: dateInput.value,
                                ceremonyDateFormatted: dateInput.value ? formatDateForDisplay(dateInput.value) : ''
                            });
                        }
                    }
                });
            }
            
            if (changes.length === 0) {
                const message = 'No changes have been made. Please select approval status for at least one candidate.';
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Validate that all changed candidates have ceremony dates
            const incomplete = changes.filter(c => !c.ceremonyDate);
            
            if (incomplete.length > 0) {
                const message = `Please ensure all candidates have ceremony dates. ${incomplete.length} candidate(s) missing ceremony date.`;
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Display review table
            displayCandidateReview(changes);
        }

        function displayCandidateReview(changes) {
            const chapterSpan = document.getElementById('candidates-review-chapter');
            const countSpan = document.getElementById('candidates-review-count');
            const tbody = document.getElementById('candidates-review-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = changes.length;
            
            if (tbody) {
                tbody.innerHTML = '';
                
                changes.forEach(change => {
                    const row = tbody.insertRow();
                    
                    // Store the candidate data on the row for later retrieval
                    row.candidateData = {
                        id: change.id,
                        code: change.code,
                        codeId: change.codeId
                    };
                    
                    // Name
                    const nameCell = row.insertCell();
                    nameCell.textContent = change.name;
                    
                    // Approval Status
                    const statusCell = row.insertCell();
                    let statusText = change.approval;
                    if (statusText === 'Candidate') statusText = 'Approve';
                    else if (statusText === 'Disapproved') statusText = 'Disapprove';
                    else if (statusText === 'Unknown') statusText = 'Person Unknown';
                    statusCell.textContent = statusText;
                    
                    // Date
                    const dateCell = row.insertCell();
                    dateCell.textContent = change.ceremonyDateFormatted;
                });
            }
            
            // Hide main content, show review
            hideElement('candidates-content');
            showElement('candidates-review');
            resizeIframe();
        }

        function backToCandidates() {
            hideElement('candidates-review');
            showElement('candidates-content');
            resizeIframe();
        }

        // INITIATES REVIEW FUNCTIONS
        function reviewInitiateChanges() {
            // Get all initiate changes
            const changes = [];
            const tbody = document.getElementById('initiates-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const initiateId = row.dataset.initiateId;
                    if (initiateId) {
                        const checkbox = document.getElementById(`initiated-${index}`);
                        const dateInput = document.getElementById(`initiate-ceremony-date-${index}`);
                        const badgeInput = document.getElementById(`badge-number-${index}`);
                        const nameCell = row.cells[1]; // Name is in second column
                        
                        if (checkbox && checkbox.checked && dateInput && badgeInput) {
                            changes.push({
                                id: initiateId,
                                code: row.dataset.code,
                                codeId: row.dataset.codeId,
                                relationId: row.dataset.relationId,
                                name: nameCell.textContent,
                                initiated: true,
                                ceremonyDate: dateInput.value,
                                ceremonyDateFormatted: dateInput.value ? formatDateForDisplay(dateInput.value) : '',
                                badgeNumber: badgeInput.value
                            });
                        }
                    }
                });
            }
            
            if (changes.length === 0) {
                const message = 'No initiates have been selected. Please check at least one initiate.';
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Validate that all selected initiates have ceremony dates and badge numbers
            const incomplete = changes.filter(i => !i.ceremonyDate || !i.badgeNumber);
            
            if (incomplete.length > 0) {
                const message = `Please ensure all selected initiates have ceremony dates and badge numbers. ${incomplete.length} initiate(s) missing required information.`;
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Validate badge numbers are greater than last badge
            if (appState.lastBadgeNumber !== null) {
                const invalidBadges = changes.filter(i => {
                    const badgeNum = parseInt(i.badgeNumber, 10);
                    return badgeNum <= appState.lastBadgeNumber;
                });
                
                if (invalidBadges.length > 0) {
                    const message = `Badge numbers must be greater than ${appState.lastBadgeNumber}. ${invalidBadges.length} initiate(s) have invalid badge numbers.`;
                    alert(message);
                    showStatus(message, 'error');
                    return;
                }
            }
            
            // Check for duplicate badge numbers
            const badgeNumbers = changes.map(c => parseInt(c.badgeNumber, 10));
            const uniqueBadgeNumbers = [...new Set(badgeNumbers)];
            
            if (badgeNumbers.length !== uniqueBadgeNumbers.length) {
                // Find the duplicate badge numbers
                const duplicates = badgeNumbers.filter((num, index) => badgeNumbers.indexOf(num) !== index);
                const uniqueDuplicates = [...new Set(duplicates)];
                const message = `Duplicate badge numbers found: ${uniqueDuplicates.join(', ')}. Each initiate must have a unique badge number.`;
                alert(message);
                showStatus(message, 'error');
                return;
            }
            
            // Only check for skipped numbers if validation is NOT disabled for this chapter
            if (!appState.skipValidationDisabled) {
                // Sort badge numbers and check for skipped numbers
                const sortedBadgeNumbers = [...badgeNumbers].sort((a, b) => a - b);
                const startingNumber = appState.lastBadgeNumber !== null ? appState.lastBadgeNumber : 0;
                
                // Check for skipped numbers from last badge to first new badge
                if (sortedBadgeNumbers[0] > startingNumber + 1) {
                    const skippedCount = sortedBadgeNumbers[0] - startingNumber - 1;
                    const skippedNumbers = [];
                    for (let i = startingNumber + 1; i < sortedBadgeNumbers[0]; i++) {
                        skippedNumbers.push(i);
                    }
                    const message = `Badge numbers must be consecutive. Skipped number(s): ${skippedNumbers.join(', ')} (${skippedCount} total) between ${startingNumber} and ${sortedBadgeNumbers[0]}.`;
                    alert(message);
                    showStatus(message, 'error');
                    return;
                }
                
                // Check for skipped numbers between new badges
                for (let i = 1; i < sortedBadgeNumbers.length; i++) {
                    if (sortedBadgeNumbers[i] > sortedBadgeNumbers[i-1] + 1) {
                        const skippedCount = sortedBadgeNumbers[i] - sortedBadgeNumbers[i-1] - 1;
                        const skippedNumbers = [];
                        for (let j = sortedBadgeNumbers[i-1] + 1; j < sortedBadgeNumbers[i]; j++) {
                            skippedNumbers.push(j);
                        }
                        const message = `Badge numbers must be consecutive. Skipped number(s): ${skippedNumbers.join(', ')} (${skippedCount} total) between ${sortedBadgeNumbers[i-1]} and ${sortedBadgeNumbers[i]}.`;
                        alert(message);
                        showStatus(message, 'error');
                        return;
                    }
                }
            } else {
                console.log('Skip validation is disabled for this chapter');
            }
            
            // Sort changes by badge number for display
            changes.sort((a, b) => parseInt(a.badgeNumber, 10) - parseInt(b.badgeNumber, 10));
            
            // Display review table
            displayInitiateReview(changes);
        }

        function displayInitiateReview(changes) {
            const chapterSpan = document.getElementById('initiates-review-chapter');
            const countSpan = document.getElementById('initiates-review-count');
            const tbody = document.getElementById('initiates-review-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = changes.length;
            
            if (tbody) {
                tbody.innerHTML = '';
                
                changes.forEach(change => {
                    const row = tbody.insertRow();
                    
                    // Name
                    const nameCell = row.insertCell();
                    nameCell.textContent = change.name;
                    
                    // Ceremony Date
                    const dateCell = row.insertCell();
                    dateCell.textContent = change.ceremonyDateFormatted;
                    
                    // Badge Number
                    const badgeCell = row.insertCell();
                    badgeCell.textContent = change.badgeNumber;
                });
            }
            
            // Hide main content, show review
            hideElement('initiates-content');
            showElement('initiates-review');
            resizeIframe();
        }

        function backToInitiates() {
            hideElement('initiates-review');
            showElement('initiates-content');
            resizeIframe();
        }

        // ROSTER REVIEW FUNCTIONS
        function reviewRosterChanges() {
            // Get all roster changes
            const changes = [];
            const tbody = document.getElementById('roster-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const memberId = row.dataset.memberId;
                    if (memberId) {
                        const statusSelect = document.getElementById(`status-${index}`);
                        const dateInput = document.getElementById(`roster-date-${index}`);
                        const nameCell = row.cells[0];
                        const currentStatusCell = row.cells[1];
                        
                        if (statusSelect && statusSelect.value && statusSelect.value !== '' && dateInput) {
                            const selectedOption = statusSelect.options[statusSelect.selectedIndex];
                            
                            changes.push({
                                id: memberId,
                                name: nameCell.textContent,
                                currentStatus: currentStatusCell.textContent,
                                newStatus: statusSelect.value,
                                newStatusText: selectedOption.textContent,
                                effectiveDate: dateInput.value,
                                effectiveDateFormatted: dateInput.value ? formatDateForDisplay(dateInput.value) : ''
                            });
                        }
                    }
                });
            }
            
            if (changes.length === 0) {
                showStatus('No changes have been made. Please select a status for at least one member.', 'error');
                return;
            }
            
            // Validate that all changes have dates
            const incomplete = changes.filter(c => !c.effectiveDate);
            
            if (incomplete.length > 0) {
                showStatus(`Please ensure all status changes have effective dates. ${incomplete.length} member(s) missing date.`, 'error');
                return;
            }
            
            // Display review table
            displayRosterReview(changes);
        }

        function displayRosterReview(changes) {
            const chapterSpan = document.getElementById('roster-review-chapter');
            const countSpan = document.getElementById('roster-review-count');
            const tbody = document.getElementById('roster-review-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = changes.length;
            
            if (tbody) {
                tbody.innerHTML = '';
                
                changes.forEach(change => {
                    const row = tbody.insertRow();
                    
                    // Name
                    const nameCell = row.insertCell();
                    nameCell.textContent = change.name;
                    
                    // Current Status
                    const currentCell = row.insertCell();
                    currentCell.textContent = change.currentStatus;
                    
                    // New Status
                    const newStatusCell = row.insertCell();
                    newStatusCell.textContent = change.newStatusText;
                    
                    // Effective Date
                    const dateCell = row.insertCell();
                    dateCell.textContent = change.effectiveDateFormatted;
                });
            }
            
            // Hide main content, show review
            hideElement('roster-content');
            showElement('roster-review');
            resizeIframe();
        }

        function backToRoster() {
            hideElement('roster-review');
            showElement('roster-content');
            resizeIframe();
        }

        // OFFICER REVIEW FUNCTIONS
        function reviewOfficerChanges() {
            // Get all officer changes
            const changes = [];
            const tbody = document.getElementById('officer-tbody');
            
            if (tbody) {
                const rows = tbody.querySelectorAll('tr');
                
                rows.forEach((row, index) => {
                    const position = row.dataset.position;
                    if (position) {
                        const officerSelect = document.getElementById(`new-officer-${index}`);
                        const dateInput = document.getElementById(`officer-start-date-${index}`);
                        const currentOfficerCell = row.cells[1];
                        
                        if (officerSelect && officerSelect.value && officerSelect.value !== '' && dateInput) {
                            const selectedOption = officerSelect.options[officerSelect.selectedIndex];
                            
                            changes.push({
                                position: position,
                                currentOfficer: currentOfficerCell.textContent === '-' ? 'None' : currentOfficerCell.textContent,
                                currentOfficerId: row.dataset.currentOfficerId || null,
                                newOfficerId: officerSelect.value,
                                newOfficerName: selectedOption.textContent,
                                startDate: dateInput.value,
                                startDateFormatted: dateInput.value ? formatDateForDisplay(dateInput.value) : ''
                            });
                        }
                    }
                });
            }
            
            if (changes.length === 0) {
                showStatus('No changes have been made. Please select a new officer for at least one position.', 'error');
                return;
            }
            
            // Validate that all changes have start dates
            const incomplete = changes.filter(c => !c.startDate);
            
            if (incomplete.length > 0) {
                showStatus(`Please ensure all officer changes have start dates. ${incomplete.length} position(s) missing date.`, 'error');
                return;
            }
            
            // Display review table
            displayOfficerReview(changes);
        }

        function displayOfficerReview(changes) {
            const chapterSpan = document.getElementById('officer-review-chapter');
            const countSpan = document.getElementById('officer-review-count');
            const tbody = document.getElementById('officer-review-tbody');
            
            if (chapterSpan) chapterSpan.textContent = appState.chapter || 'Unknown';
            if (countSpan) countSpan.textContent = changes.length;
            
            if (tbody) {
                tbody.innerHTML = '';
                
                changes.forEach(change => {
                    const row = tbody.insertRow();
                    
                    // Position
                    const positionCell = row.insertCell();
                    positionCell.textContent = change.position;
                    
                    // Current Officer
                    const currentCell = row.insertCell();
                    currentCell.textContent = change.currentOfficer;
                    
                    // New Officer
                    const newOfficerCell = row.insertCell();
                    newOfficerCell.textContent = change.newOfficerName;
                    
                    // Start Date
                    const dateCell = row.insertCell();
                    dateCell.textContent = change.startDateFormatted;
                });
            }
            
            // Hide main content, show review
            hideElement('officer-content');
            showElement('officer-review');
            resizeIframe();
        }

        function backToOfficers() {
            hideElement('officer-review');
            showElement('officer-content');
            resizeIframe();
        }

        // Admin/Testing function
        async function testApiCall() {
            if (!isTokenValid()) {
                showStatus('No valid token. Please authenticate first.', 'error');
                return;
            }
            
            const endpoint = document.getElementById('customEndpoint').value || 
                           document.getElementById('apiEndpoint').value;
            
            const responseArea = document.getElementById('apiResponse');
            if (responseArea) {
                responseArea.style.display = 'block';
                responseArea.textContent = 'Making API call...';
            }
            
            try {
                // Add SID and Chapter to endpoint if available
                let fullEndpoint = endpoint;
                if (appState.sid && endpoint.includes('{sid}')) {
                    fullEndpoint = fullEndpoint.replace('{sid}', appState.sid);
                }
                if (appState.chapter && endpoint.includes('{chapter}')) {
                    fullEndpoint = fullEndpoint.replace('{chapter}', appState.chapter);
                }
                
                const response = await fetch(`/api/blackbaud?action=api&endpoint=${encodeURIComponent(fullEndpoint)}&token=${appState.accessToken}`, {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    throw new Error(`API call failed: ${response.status}`);
                }
                
                const data = await response.json();
                if (responseArea) {
                    responseArea.textContent = JSON.stringify(data, null, 2);
                }
                showStatus('Test API call successful!', 'success');
                
            } catch (error) {
                console.error('API call error:', error);
                if (responseArea) {
                    responseArea.textContent = `Error: ${error.message}`;
                }
                showStatus(`Test API call failed: ${error.message}`, 'error');
            }
        }

        // ALLOW SKIPS CONFIGURATION FUNCTIONS
        async function loadAllowSkipsConfig() {
            console.log('=== loadAllowSkipsConfig() started ===');
            
            // Check if we have a chapter
            if (!appState.chapter) {
                hideElement('allow-skips-loading');
                hideElement('allow-skips-content');
                hideElement('allow-skips-error');
                return;
            }
            
            // Show loading state
            showLoading('allow-skips-loading');
            hideElement('allow-skips-content');
            hideElement('allow-skips-error');
            
            try {
                // Get allowed skips data from server
                const response = await fetch('/api/blackbaud?action=get-allowed-skips', {
                    method: 'GET'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load configuration');
                }
                
                const allowedSkips = await response.json();
                appState.allowedSkips = allowedSkips;
                
                // Display the configuration for current chapter
                displayAllowSkipsConfig(allowedSkips);
                
            } catch (error) {
                console.error('Error loading allow skips config:', error);
                hideElement('allow-skips-loading');
                showElement('allow-skips-error');
            }
        }

        function displayAllowSkipsConfig(allowedSkips) {
            console.log('=== displayAllowSkipsConfig() started ===');
            
            const checkbox = document.getElementById('allow-skips-checkbox');
            const chapterNameSpan = document.getElementById('current-chapter-name');
            
            if (checkbox && appState.chapter) {
                // Update chapter name in label
                if (chapterNameSpan) {
                    chapterNameSpan.textContent = appState.chapter;
                }
                
                // Set checkbox state
                checkbox.checked = allowedSkips[appState.chapter] === true;
                
                // Remove any existing event listeners
                const newCheckbox = checkbox.cloneNode(true);
                checkbox.parentNode.replaceChild(newCheckbox, checkbox);
                
                // Add event listener
                newCheckbox.addEventListener('change', function() {
                    updateAllowSkips(appState.chapter, this.checked);
                });
            }
            
            // Show content
            hideElement('allow-skips-loading');
            showElement('allow-skips-content');
        }

        async function updateAllowSkips(chapter, allowSkips) {
            console.log(`Updating allow skips for ${chapter} to ${allowSkips}`);
            
            try {
                const response = await fetch('/api/blackbaud?action=set-allowed-skips', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ chapter, allowSkips })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to update configuration');
                }
                
                // Update local state
                appState.allowedSkips[chapter] = allowSkips;
                
                showStatus(`Badge skip validation ${allowSkips ? 'disabled' : 'enabled'} for ${chapter}`, 'success');
                
            } catch (error) {
                console.error('Error updating allow skips:', error);
                showStatus('Failed to update configuration', 'error');
                // Revert checkbox
                const checkbox = document.getElementById('allow-skips-checkbox');
                if (checkbox) checkbox.checked = !allowSkips;
            }
        }

        // Get allowed skips for current chapter
        async function checkAllowedSkips() {
            if (!appState.chapter) return false;
            
            try {
                const response = await fetch('/api/blackbaud?action=get-allowed-skips', {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const allowedSkips = await response.json();
                    appState.allowedSkips = allowedSkips;
                    return allowedSkips[appState.chapter] === true;
                }
            } catch (error) {
                console.error('Error checking allowed skips:', error);
            }
            
            return false;
        }
    </script>
</body>
</html>